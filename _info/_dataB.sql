-- MySQL Script generated by MySQL Workbench
-- Wed Jun  6 22:17:56 2018
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';

-- -----------------------------------------------------
-- Schema dbChurchill
-- -----------------------------------------------------
DROP SCHEMA IF EXISTS `dbChurchill` ;

-- -----------------------------------------------------
-- Schema dbChurchill
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `dbChurchill` DEFAULT CHARACTER SET utf8 COLLATE utf8_spanish_ci ;
USE `dbChurchill` ;

-- -----------------------------------------------------
-- Table `dbChurchill`.`estadoUsuario`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`estadoUsuario` (
  `idEstadoUsuario` INT NOT NULL,
  `estadoUsuario` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idEstadoUsuario`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`perfil`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`perfil` (
  `idPerfil` INT NOT NULL,
  `perfil` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idPerfil`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`destinoMenu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`destinoMenu` (
  `idDestinoMenu` INT NOT NULL AUTO_INCREMENT,
  `destinoMenu` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idDestinoMenu`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`usuario`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`usuario` (
  `usuario` VARCHAR(15) NOT NULL,
  `idEstadoUsuario` INT NOT NULL,
  `idPerfil` INT NOT NULL,
  `idDestinoMenu` INT NOT NULL,
  `codigo` INT(4) NOT NULL,
  `clave` VARCHAR(75) NOT NULL,
  `nombres` VARCHAR(65) NOT NULL,
  `apellidos` VARCHAR(65) NOT NULL,
  `usuarioRegistro` VARCHAR(15) NULL,
  `fechaRegistro` DATETIME NOT NULL,
  PRIMARY KEY (`usuario`),
  INDEX `fk_usuario_estadoUsuario1_idx` (`idEstadoUsuario` ASC),
  UNIQUE INDEX `codigo_UNIQUE` (`codigo` ASC),
  INDEX `fk_usuario_perfil1_idx` (`idPerfil` ASC),
  INDEX `fk_usuario_usuario1_idx` (`usuarioRegistro` ASC),
  INDEX `fk_usuario_destinoMenu1_idx` (`idDestinoMenu` ASC),
  CONSTRAINT `fk_usuario_estadoUsuario1`
    FOREIGN KEY (`idEstadoUsuario`)
    REFERENCES `dbChurchill`.`estadoUsuario` (`idEstadoUsuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_usuario_perfil1`
    FOREIGN KEY (`idPerfil`)
    REFERENCES `dbChurchill`.`perfil` (`idPerfil`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_usuario_usuario1`
    FOREIGN KEY (`usuarioRegistro`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_usuario_destinoMenu1`
    FOREIGN KEY (`idDestinoMenu`)
    REFERENCES `dbChurchill`.`destinoMenu` (`idDestinoMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`modulo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`modulo` (
  `idModulo` INT NOT NULL,
  `modulo` VARCHAR(45) NOT NULL,
  `ruta` VARCHAR(45) NOT NULL,
  `img` VARCHAR(75) NOT NULL,
  `habilitado` TINYINT(1) NOT NULL,
  PRIMARY KEY (`idModulo`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`perfilModulo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`perfilModulo` (
  `idPerfil` INT NOT NULL,
  `idModulo` INT NOT NULL,
  PRIMARY KEY (`idPerfil`, `idModulo`),
  INDEX `fk_perfil_has_modulo_modulo1_idx` (`idModulo` ASC),
  INDEX `fk_perfil_has_modulo_perfil1_idx` (`idPerfil` ASC),
  CONSTRAINT `fk_perfil_has_modulo_perfil1`
    FOREIGN KEY (`idPerfil`)
    REFERENCES `dbChurchill`.`perfil` (`idPerfil`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_perfil_has_modulo_modulo1`
    FOREIGN KEY (`idModulo`)
    REFERENCES `dbChurchill`.`modulo` (`idModulo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`tipoRespuesta`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`tipoRespuesta` (
  `idTipoRespuesta` INT NOT NULL,
  `tipoRespuesta` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idTipoRespuesta`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`historialAutenticacion`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`historialAutenticacion` (
  `usuario` VARCHAR(15) NOT NULL,
  `idTipoRespuesta` INT NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  INDEX `fk_historialSesion_usuario1_idx` (`usuario` ASC),
  INDEX `fk_historialAutenticacion_tipoRespuesta1_idx` (`idTipoRespuesta` ASC),
  CONSTRAINT `fk_historialSesion_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_historialAutenticacion_tipoRespuesta1`
    FOREIGN KEY (`idTipoRespuesta`)
    REFERENCES `dbChurchill`.`tipoRespuesta` (`idTipoRespuesta`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`log_estadoUsuario`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`log_estadoUsuario` (
  `idEstadoUsuario` INT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `usuarioRegistro` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  INDEX `fk_estadoUsuario_has_usuario_usuario1_idx` (`usuario` ASC),
  INDEX `fk_estadoUsuario_has_usuario_estadoUsuario1_idx` (`idEstadoUsuario` ASC),
  INDEX `fk_estadoUsuario_has_usuario_usuario2_idx` (`usuarioRegistro` ASC),
  CONSTRAINT `fk_estadoUsuario_has_usuario_estadoUsuario1`
    FOREIGN KEY (`idEstadoUsuario`)
    REFERENCES `dbChurchill`.`estadoUsuario` (`idEstadoUsuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_estadoUsuario_has_usuario_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_estadoUsuario_has_usuario_usuario2`
    FOREIGN KEY (`usuarioRegistro`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`tipoCliente`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`tipoCliente` (
  `idTipoCliente` INT NOT NULL,
  `tipoCliente` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idTipoCliente`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`cliente`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`cliente` (
  `idCliente` INT NOT NULL AUTO_INCREMENT,
  `nit` VARCHAR(15) NOT NULL,
  `nombre` VARCHAR(65) NOT NULL,
  `cui` VARCHAR(13) NULL,
  `correo` VARCHAR(65) NULL,
  `telefono` VARCHAR(45) NULL,
  `direccion` VARCHAR(95) NULL,
  `idTipoCliente` INT NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  PRIMARY KEY (`idCliente`),
  INDEX `fk_cliente_tipoCliente1_idx` (`idTipoCliente` ASC),
  INDEX `ix_usuario` (`usuario` ASC),
  CONSTRAINT `fk_cliente_tipoCliente1`
    FOREIGN KEY (`idTipoCliente`)
    REFERENCES `dbChurchill`.`tipoCliente` (`idTipoCliente`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_cliente_usuario`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`estadoMenu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`estadoMenu` (
  `idEstadoMenu` INT NOT NULL AUTO_INCREMENT,
  `estadoMenu` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idEstadoMenu`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`tipoMenu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`tipoMenu` (
  `idTipoMenu` INT NOT NULL AUTO_INCREMENT,
  `tipoMenu` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idTipoMenu`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`menu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`menu` (
  `idMenu` INT NOT NULL AUTO_INCREMENT,
  `menu` VARCHAR(45) NOT NULL,
  `imagen` VARCHAR(125) NULL,
  `descripcion` TEXT NOT NULL,
  `idEstadoMenu` INT NOT NULL,
  `idDestinoMenu` INT NOT NULL,
  `top` INT NOT NULL,
  `idTipoMenu` INT NOT NULL,
  `codigo` INT NOT NULL,
  `tiempoAlerta` INT NULL,
  `seCocina` TINYINT(1) NOT NULL,
  PRIMARY KEY (`idMenu`),
  INDEX `fk_menu_estadoMenu1_idx` (`idEstadoMenu` ASC),
  INDEX `fk_menu_destinoMenu1_idx` (`idDestinoMenu` ASC),
  INDEX `fk_menu_tipoMenu1_idx` (`idTipoMenu` ASC),
  CONSTRAINT `fk_menu_estadoMenu1`
    FOREIGN KEY (`idEstadoMenu`)
    REFERENCES `dbChurchill`.`estadoMenu` (`idEstadoMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_menu_destinoMenu1`
    FOREIGN KEY (`idDestinoMenu`)
    REFERENCES `dbChurchill`.`destinoMenu` (`idDestinoMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_menu_tipoMenu1`
    FOREIGN KEY (`idTipoMenu`)
    REFERENCES `dbChurchill`.`tipoMenu` (`idTipoMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`tipoProducto`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`tipoProducto` (
  `idTipoProducto` INT NOT NULL AUTO_INCREMENT,
  `tipoProducto` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idTipoProducto`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`medida`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`medida` (
  `idMedida` INT NOT NULL AUTO_INCREMENT,
  `medida` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idMedida`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`ubicacion`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`ubicacion` (
  `idUbicacion` INT NOT NULL,
  `ubicacion` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idUbicacion`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`producto`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`producto` (
  `idProducto` INT NOT NULL AUTO_INCREMENT,
  `producto` VARCHAR(45) NOT NULL,
  `idTipoProducto` INT NOT NULL,
  `idMedida` INT NOT NULL,
  `perecedero` TINYINT(1) NOT NULL,
  `cantidadMinima` DOUBLE(10,2) NOT NULL,
  `cantidadMaxima` DOUBLE(10,2) NULL,
  `disponibilidad` DOUBLE(10,2) NOT NULL,
  `importante` TINYINT(1) NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `idUbicacion` INT NOT NULL,
  PRIMARY KEY (`idProducto`),
  INDEX `fk_producto_tipoProducto1_idx` (`idTipoProducto` ASC),
  INDEX `fk_producto_medida1_idx` (`idMedida` ASC),
  INDEX `ix_usuario` (`usuario` ASC),
  INDEX `fk_producto_ubicacion1_idx` (`idUbicacion` ASC),
  CONSTRAINT `fk_producto_tipoProducto1`
    FOREIGN KEY (`idTipoProducto`)
    REFERENCES `dbChurchill`.`tipoProducto` (`idTipoProducto`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_producto_medida1`
    FOREIGN KEY (`idMedida`)
    REFERENCES `dbChurchill`.`medida` (`idMedida`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_usuario`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_producto_ubicacion1`
    FOREIGN KEY (`idUbicacion`)
    REFERENCES `dbChurchill`.`ubicacion` (`idUbicacion`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`combo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`combo` (
  `idCombo` INT NOT NULL AUTO_INCREMENT,
  `combo` VARCHAR(45) NOT NULL,
  `imagen` VARCHAR(125) NULL,
  `descripcion` TEXT NOT NULL,
  `idEstadoMenu` INT NOT NULL,
  `top` INT NOT NULL,
  `codigo` INT NULL,
  PRIMARY KEY (`idCombo`),
  INDEX `fk_combo_estadoMenu1_idx` (`idEstadoMenu` ASC),
  CONSTRAINT `fk_combo_estadoMenu1`
    FOREIGN KEY (`idEstadoMenu`)
    REFERENCES `dbChurchill`.`estadoMenu` (`idEstadoMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`comboDetalle`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`comboDetalle` (
  `idCombo` INT NOT NULL,
  `idMenu` INT NOT NULL,
  `cantidad` DOUBLE(10,2) NOT NULL,
  PRIMARY KEY (`idCombo`, `idMenu`),
  INDEX `fk_combo_has_menu_menu1_idx` (`idMenu` ASC),
  INDEX `fk_combo_has_menu_combo1_idx` (`idCombo` ASC),
  CONSTRAINT `fk_combo_has_menu_combo1`
    FOREIGN KEY (`idCombo`)
    REFERENCES `dbChurchill`.`combo` (`idCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_combo_has_menu_menu1`
    FOREIGN KEY (`idMenu`)
    REFERENCES `dbChurchill`.`menu` (`idMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`receta`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`receta` (
  `idMenu` INT NOT NULL,
  `idProducto` INT NOT NULL,
  `cantidad` DOUBLE(10,2) NOT NULL,
  `observacion` TEXT NULL,
  PRIMARY KEY (`idMenu`, `idProducto`),
  INDEX `fk_menu_has_producto_producto1_idx` (`idProducto` ASC),
  INDEX `fk_menu_has_producto_menu1_idx` (`idMenu` ASC),
  CONSTRAINT `fk_menu_has_producto_menu1`
    FOREIGN KEY (`idMenu`)
    REFERENCES `dbChurchill`.`menu` (`idMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_menu_has_producto_producto1`
    FOREIGN KEY (`idProducto`)
    REFERENCES `dbChurchill`.`producto` (`idProducto`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`tipoServicio`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`tipoServicio` (
  `idTipoServicio` INT NOT NULL,
  `tipoServicio` VARCHAR(45) NOT NULL,
  `orden` INT NOT NULL,
  PRIMARY KEY (`idTipoServicio`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`menuPrecio`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`menuPrecio` (
  `idMenu` INT NOT NULL,
  `idTipoServicio` INT NOT NULL,
  `precio` DOUBLE(10,2) NOT NULL,
  PRIMARY KEY (`idMenu`, `idTipoServicio`),
  INDEX `fk_tipoServicio_has_menu_menu1_idx` (`idMenu` ASC),
  INDEX `fk_tipoServicio_has_menu_tipoServicio1_idx` (`idTipoServicio` ASC),
  CONSTRAINT `fk_tipoServicio_has_menu_tipoServicio1`
    FOREIGN KEY (`idTipoServicio`)
    REFERENCES `dbChurchill`.`tipoServicio` (`idTipoServicio`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_tipoServicio_has_menu_menu1`
    FOREIGN KEY (`idMenu`)
    REFERENCES `dbChurchill`.`menu` (`idMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`superCombo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`superCombo` (
  `idSuperCombo` INT NOT NULL AUTO_INCREMENT,
  `superCombo` VARCHAR(45) NOT NULL,
  `imagen` VARCHAR(125) NULL,
  `descripcion` TEXT NOT NULL,
  `idEstadoMenu` INT NOT NULL,
  `top` INT NOT NULL,
  `codigo` INT NULL,
  PRIMARY KEY (`idSuperCombo`),
  INDEX `fk_superCombo_estadoMenu1_idx` (`idEstadoMenu` ASC),
  CONSTRAINT `fk_superCombo_estadoMenu1`
    FOREIGN KEY (`idEstadoMenu`)
    REFERENCES `dbChurchill`.`estadoMenu` (`idEstadoMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`superComboDetalle`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`superComboDetalle` (
  `idCombo` INT NOT NULL,
  `idSuperCombo` INT NOT NULL,
  `cantidad` DOUBLE(10,2) NOT NULL,
  PRIMARY KEY (`idCombo`, `idSuperCombo`),
  INDEX `fk_combo_has_superCombo_superCombo1_idx` (`idSuperCombo` ASC),
  INDEX `fk_combo_has_superCombo_combo1_idx` (`idCombo` ASC),
  CONSTRAINT `fk_combo_has_superCombo_combo1`
    FOREIGN KEY (`idCombo`)
    REFERENCES `dbChurchill`.`combo` (`idCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_combo_has_superCombo_superCombo1`
    FOREIGN KEY (`idSuperCombo`)
    REFERENCES `dbChurchill`.`superCombo` (`idSuperCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`comboPrecio`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`comboPrecio` (
  `idCombo` INT NOT NULL,
  `idTipoServicio` INT NOT NULL,
  `precio` DOUBLE(10,2) NOT NULL,
  PRIMARY KEY (`idCombo`, `idTipoServicio`),
  INDEX `fk_combo_has_tipoServicio_tipoServicio1_idx` (`idTipoServicio` ASC),
  INDEX `fk_combo_has_tipoServicio_combo1_idx` (`idCombo` ASC),
  CONSTRAINT `fk_combo_has_tipoServicio_combo1`
    FOREIGN KEY (`idCombo`)
    REFERENCES `dbChurchill`.`combo` (`idCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_combo_has_tipoServicio_tipoServicio1`
    FOREIGN KEY (`idTipoServicio`)
    REFERENCES `dbChurchill`.`tipoServicio` (`idTipoServicio`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`superComboPrecio`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`superComboPrecio` (
  `idSuperCombo` INT NOT NULL,
  `idTipoServicio` INT NOT NULL,
  `precio` DOUBLE(10,2) NOT NULL,
  PRIMARY KEY (`idSuperCombo`, `idTipoServicio`),
  INDEX `fk_superCombo_has_tipoServicio_tipoServicio1_idx` (`idTipoServicio` ASC),
  INDEX `fk_superCombo_has_tipoServicio_superCombo1_idx` (`idSuperCombo` ASC),
  CONSTRAINT `fk_superCombo_has_tipoServicio_superCombo1`
    FOREIGN KEY (`idSuperCombo`)
    REFERENCES `dbChurchill`.`superCombo` (`idSuperCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_superCombo_has_tipoServicio_tipoServicio1`
    FOREIGN KEY (`idTipoServicio`)
    REFERENCES `dbChurchill`.`tipoServicio` (`idTipoServicio`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`venta`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`venta` (
  `idVenta` INT NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`idVenta`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`estadoOrden`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`estadoOrden` (
  `idEstadoOrden` INT NOT NULL,
  `estadoOrden` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idEstadoOrden`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`ordenCliente`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`ordenCliente` (
  `idOrdenCliente` INT NOT NULL AUTO_INCREMENT,
  `numeroTicket` INT NULL,
  `usuarioPropietario` VARCHAR(15) NOT NULL,
  `usuarioResponsable` VARCHAR(15) NOT NULL,
  `idEstadoOrden` INT NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `numMenu` INT NOT NULL,
  `numeroGrupo` INT NOT NULL,
  PRIMARY KEY (`idOrdenCliente`),
  INDEX `ix_numeroTicket` (`numeroTicket` ASC),
  INDEX `fk_ordenCliente_estadoOrden1_idx` (`idEstadoOrden` ASC),
  INDEX `ix_usuarioResponsable` (`usuarioResponsable` ASC),
  INDEX `ix_usuarioPropietario` (`usuarioPropietario` ASC),
  CONSTRAINT `fk_ordenCliente_estadoOrden1`
    FOREIGN KEY (`idEstadoOrden`)
    REFERENCES `dbChurchill`.`estadoOrden` (`idEstadoOrden`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_usuarioResponsable`
    FOREIGN KEY (`usuarioResponsable`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_usuarioPropietario`
    FOREIGN KEY (`usuarioPropietario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`estadoDetalleOrden`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`estadoDetalleOrden` (
  `idEstadoDetalleOrden` INT NOT NULL,
  `estadoDetalleOrden` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idEstadoDetalleOrden`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`detalleOrdenMenu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`detalleOrdenMenu` (
  `idDetalleOrdenMenu` INT NOT NULL AUTO_INCREMENT,
  `idOrdenCliente` INT NOT NULL,
  `idMenu` INT NOT NULL,
  `cantidad` DOUBLE(10,2) NOT NULL,
  `idEstadoDetalleOrden` INT NOT NULL,
  `idTipoServicio` INT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `usuarioResponsable` VARCHAR(15) NOT NULL,
  `perteneceCombo` TINYINT(1) NOT NULL,
  `observacion` TEXT NULL,
  INDEX `fk_detalleOdenMenu_ordenCliente1_idx` (`idOrdenCliente` ASC),
  INDEX `fk_detalleOdenMenu_menu1_idx` (`idMenu` ASC),
  INDEX `fk_detalleOdenMenu_estadoDetalleOrden1_idx` (`idEstadoDetalleOrden` ASC),
  PRIMARY KEY (`idDetalleOrdenMenu`),
  INDEX `fk_detalleOdenMenu_tipoServicio1_idx` (`idTipoServicio` ASC),
  INDEX `fk_detalleOdenMenu_usuario1_idx` (`usuario` ASC),
  INDEX `fk_detalleOdenMenu_usuario2_idx` (`usuarioResponsable` ASC),
  CONSTRAINT `fk_detalleOdenMenu_ordenCliente1`
    FOREIGN KEY (`idOrdenCliente`)
    REFERENCES `dbChurchill`.`ordenCliente` (`idOrdenCliente`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenMenu_menu1`
    FOREIGN KEY (`idMenu`)
    REFERENCES `dbChurchill`.`menu` (`idMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenMenu_estadoDetalleOrden1`
    FOREIGN KEY (`idEstadoDetalleOrden`)
    REFERENCES `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenMenu_tipoServicio1`
    FOREIGN KEY (`idTipoServicio`)
    REFERENCES `dbChurchill`.`tipoServicio` (`idTipoServicio`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenMenu_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenMenu_usuario2`
    FOREIGN KEY (`usuarioResponsable`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`bitacoraOrdenCliente`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`bitacoraOrdenCliente` (
  `idEstadoOrden` INT NOT NULL,
  `idOrdenCliente` INT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `comentario` TEXT NULL,
  INDEX `fk_estadoOrden_has_ordenCliente_ordenCliente1_idx` (`idOrdenCliente` ASC),
  INDEX `fk_estadoOrden_has_ordenCliente_estadoOrden1_idx` (`idEstadoOrden` ASC),
  INDEX `fk_bitacoraOrdenCliente_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_estadoOrden_has_ordenCliente_estadoOrden1`
    FOREIGN KEY (`idEstadoOrden`)
    REFERENCES `dbChurchill`.`estadoOrden` (`idEstadoOrden`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_estadoOrden_has_ordenCliente_ordenCliente1`
    FOREIGN KEY (`idOrdenCliente`)
    REFERENCES `dbChurchill`.`ordenCliente` (`idOrdenCliente`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_bitacoraOrdenCliente_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`bitacoraOrdenMenu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`bitacoraOrdenMenu` (
  `idEstadoDetalleOrden` INT NOT NULL,
  `idDetalleOrdenMenu` INT NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `comentario` TEXT NULL,
  INDEX `fk_estadoDetalleOrden_has_detalleOdenMenu_detalleOdenMenu1_idx` (`idDetalleOrdenMenu` ASC),
  INDEX `fk_estadoDetalleOrden_has_detalleOdenMenu_estadoDetalleOrde_idx` (`idEstadoDetalleOrden` ASC),
  INDEX `fk_bitacoraOdenMenu_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_estadoDetalleOrden_has_detalleOdenMenu_estadoDetalleOrden1`
    FOREIGN KEY (`idEstadoDetalleOrden`)
    REFERENCES `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_estadoDetalleOrden_has_detalleOdenMenu_detalleOdenMenu1`
    FOREIGN KEY (`idDetalleOrdenMenu`)
    REFERENCES `dbChurchill`.`detalleOrdenMenu` (`idDetalleOrdenMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_bitacoraOdenMenu_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`detalleOrdenCombo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`detalleOrdenCombo` (
  `idDetalleOrdenCombo` INT NOT NULL AUTO_INCREMENT,
  `idOrdenCliente` INT NOT NULL,
  `idCombo` INT NOT NULL,
  `cantidad` DOUBLE(10,2) NOT NULL,
  `idEstadoDetalleOrden` INT NOT NULL,
  `idTipoServicio` INT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `usuarioResponsable` VARCHAR(15) NOT NULL,
  `observacion` TEXT NULL,
  INDEX `fk_detalleOdenMenu_ordenCliente1_idx` (`idOrdenCliente` ASC),
  INDEX `fk_detalleOdenMenu_estadoDetalleOrden1_idx` (`idEstadoDetalleOrden` ASC),
  PRIMARY KEY (`idDetalleOrdenCombo`),
  INDEX `fk_detalleOdenCombo_combo1_idx` (`idCombo` ASC),
  INDEX `fk_detalleOdenCombo_tipoServicio1_idx` (`idTipoServicio` ASC),
  INDEX `fk_detalleOdenCombo_usuario1_idx` (`usuario` ASC),
  INDEX `fk_detalleOdenCombo_usuario2_idx` (`usuarioResponsable` ASC),
  CONSTRAINT `fk_detalleOdenMenu_ordenCliente10`
    FOREIGN KEY (`idOrdenCliente`)
    REFERENCES `dbChurchill`.`ordenCliente` (`idOrdenCliente`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenMenu_estadoDetalleOrden10`
    FOREIGN KEY (`idEstadoDetalleOrden`)
    REFERENCES `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenCombo_combo1`
    FOREIGN KEY (`idCombo`)
    REFERENCES `dbChurchill`.`combo` (`idCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenCombo_tipoServicio1`
    FOREIGN KEY (`idTipoServicio`)
    REFERENCES `dbChurchill`.`tipoServicio` (`idTipoServicio`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenCombo_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOdenCombo_usuario2`
    FOREIGN KEY (`usuarioResponsable`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`estadoFactura`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`estadoFactura` (
  `idEstadoFactura` INT NOT NULL,
  `estadoFactura` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idEstadoFactura`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`facturaCompra`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`facturaCompra` (
  `idFacturaCompra` INT NOT NULL AUTO_INCREMENT,
  `idEstadoFactura` INT NOT NULL,
  `noFactura` VARCHAR(15) NULL,
  `proveedor` VARCHAR(45) NOT NULL,
  `fechaFactura` DATE NOT NULL,
  `comentario` TEXT NULL,
  PRIMARY KEY (`idFacturaCompra`),
  INDEX `fk_facturaCompra_estadoFactura1_idx` (`idEstadoFactura` ASC),
  CONSTRAINT `fk_facturaCompra_estadoFactura1`
    FOREIGN KEY (`idEstadoFactura`)
    REFERENCES `dbChurchill`.`estadoFactura` (`idEstadoFactura`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`ingreso`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`ingreso` (
  `idIngreso` INT NOT NULL AUTO_INCREMENT,
  `idFacturaCompra` INT NOT NULL,
  `idProducto` INT NOT NULL,
  `cantidad` DOUBLE(10,2) NOT NULL,
  `costo` DOUBLE(12,2) NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  PRIMARY KEY (`idIngreso`),
  INDEX `fk_ingreso_producto1_idx` (`idProducto` ASC),
  INDEX `fk_ingreso_usuario1_idx` (`usuario` ASC),
  INDEX `fk_ingreso_facturaCompra1_idx` (`idFacturaCompra` ASC),
  CONSTRAINT `fk_ingreso_producto1`
    FOREIGN KEY (`idProducto`)
    REFERENCES `dbChurchill`.`producto` (`idProducto`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_ingreso_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_ingreso_facturaCompra1`
    FOREIGN KEY (`idFacturaCompra`)
    REFERENCES `dbChurchill`.`facturaCompra` (`idFacturaCompra`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`bitacoraIngreso`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`bitacoraIngreso` (
  `idProducto` INT NOT NULL,
  `cantidad` DOUBLE(10,2) NOT NULL,
  `accion` VARCHAR(45) NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  INDEX `fk_bitacoraIngreso_producto1_idx` (`idProducto` ASC),
  INDEX `fk_bitacoraIngreso_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_bitacoraIngreso_producto1`
    FOREIGN KEY (`idProducto`)
    REFERENCES `dbChurchill`.`producto` (`idProducto`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_bitacoraIngreso_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`estadoCaja`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`estadoCaja` (
  `idEstadoCaja` INT NOT NULL,
  `estadoCaja` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idEstadoCaja`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`caja`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`caja` (
  `idCaja` INT NOT NULL AUTO_INCREMENT,
  `usuario` VARCHAR(15) NOT NULL,
  `idEstadoCaja` INT NOT NULL,
  `fechaApertura` DATE NOT NULL,
  `efectivoInicial` DOUBLE(12,2) NOT NULL,
  `efectivoFinal` DOUBLE(12,2) NOT NULL,
  `efectivoSobrante` DOUBLE(10,2) NOT NULL,
  `efectivoFaltante` DOUBLE(10,2) NOT NULL,
  PRIMARY KEY (`idCaja`),
  INDEX `fk_caja_usuario1_idx` (`usuario` ASC),
  INDEX `fk_caja_estadoCaja1_idx` (`idEstadoCaja` ASC),
  CONSTRAINT `fk_caja_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_caja_estadoCaja1`
    FOREIGN KEY (`idEstadoCaja`)
    REFERENCES `dbChurchill`.`estadoCaja` (`idEstadoCaja`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`factura`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`factura` (
  `idFactura` INT NOT NULL AUTO_INCREMENT,
  `idEstadoFactura` INT NOT NULL,
  `idCliente` INT NOT NULL,
  `idCaja` INT NOT NULL,
  `nombre` VARCHAR(60) NOT NULL,
  `direccion` VARCHAR(75) NOT NULL,
  `total` DOUBLE(12,2) NOT NULL,
  `fechaFactura` DATE NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `descripcion` VARCHAR(125) NULL,
  PRIMARY KEY (`idFactura`),
  INDEX `fk_factura_cliente1_idx` (`idCliente` ASC),
  INDEX `fk_factura_caja1_idx` (`idCaja` ASC),
  INDEX `fk_factura_estadoFactura1_idx` (`idEstadoFactura` ASC),
  INDEX `fk_factura_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_factura_cliente1`
    FOREIGN KEY (`idCliente`)
    REFERENCES `dbChurchill`.`cliente` (`idCliente`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_factura_caja1`
    FOREIGN KEY (`idCaja`)
    REFERENCES `dbChurchill`.`caja` (`idCaja`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_factura_estadoFactura1`
    FOREIGN KEY (`idEstadoFactura`)
    REFERENCES `dbChurchill`.`estadoFactura` (`idEstadoFactura`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_factura_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`estadoEvento`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`estadoEvento` (
  `idEstadoEvento` INT NOT NULL,
  `estadoEvento` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idEstadoEvento`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`salon`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`salon` (
  `idSalon` INT NOT NULL,
  `salon` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idSalon`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`evento`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`evento` (
  `idEvento` INT NOT NULL AUTO_INCREMENT,
  `evento` VARCHAR(75) NOT NULL,
  `idCliente` INT NOT NULL,
  `fechaEvento` DATE NOT NULL,
  `idSalon` INT NOT NULL,
  `idEstadoEvento` INT NOT NULL,
  `numeroPersonas` INT NOT NULL,
  `horaInicio` TIME NOT NULL,
  `horaFinal` TIME NOT NULL,
  `observacion` TEXT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `idFactura` INT NULL,
  PRIMARY KEY (`idEvento`),
  INDEX `fk_evento_cliente1_idx` (`idCliente` ASC),
  INDEX `fk_evento_estadoEvento1_idx` (`idEstadoEvento` ASC),
  INDEX `fk_evento_usuario1_idx` (`usuario` ASC),
  INDEX `fk_evento_salon1_idx` (`idSalon` ASC),
  INDEX `fk_evento_factura1_idx` (`idFactura` ASC),
  CONSTRAINT `fk_evento_cliente1`
    FOREIGN KEY (`idCliente`)
    REFERENCES `dbChurchill`.`cliente` (`idCliente`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_evento_estadoEvento1`
    FOREIGN KEY (`idEstadoEvento`)
    REFERENCES `dbChurchill`.`estadoEvento` (`idEstadoEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_evento_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_evento_salon1`
    FOREIGN KEY (`idSalon`)
    REFERENCES `dbChurchill`.`salon` (`idSalon`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_evento_factura1`
    FOREIGN KEY (`idFactura`)
    REFERENCES `dbChurchill`.`factura` (`idFactura`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`eventoOrdenCliente`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`eventoOrdenCliente` (
  `idEvento` INT NOT NULL,
  `idOrdenCliente` INT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  PRIMARY KEY (`idEvento`, `idOrdenCliente`),
  INDEX `fk_evento_has_ordenCliente_ordenCliente1_idx` (`idOrdenCliente` ASC),
  INDEX `fk_evento_has_ordenCliente_evento1_idx` (`idEvento` ASC),
  INDEX `fk_eventoOrdenCliente_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_evento_has_ordenCliente_evento1`
    FOREIGN KEY (`idEvento`)
    REFERENCES `dbChurchill`.`evento` (`idEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_evento_has_ordenCliente_ordenCliente1`
    FOREIGN KEY (`idOrdenCliente`)
    REFERENCES `dbChurchill`.`ordenCliente` (`idOrdenCliente`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_eventoOrdenCliente_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`bitacoraEstadoEvento`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`bitacoraEstadoEvento` (
  `idEstadoEvento` INT NOT NULL,
  `idEvento` INT NOT NULL,
  `comentario` TEXT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  INDEX `fk_estadoEvento_has_evento_evento1_idx` (`idEvento` ASC),
  INDEX `fk_estadoEvento_has_evento_estadoEvento1_idx` (`idEstadoEvento` ASC),
  INDEX `fk_bitacoraEstadoEvento_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_estadoEvento_has_evento_estadoEvento1`
    FOREIGN KEY (`idEstadoEvento`)
    REFERENCES `dbChurchill`.`estadoEvento` (`idEstadoEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_estadoEvento_has_evento_evento1`
    FOREIGN KEY (`idEvento`)
    REFERENCES `dbChurchill`.`evento` (`idEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_bitacoraEstadoEvento_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`bitacoraOrdenCombo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`bitacoraOrdenCombo` (
  `idEstadoDetalleOrden` INT NOT NULL,
  `idDetalleOrdenCombo` INT NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `comentario` TEXT NULL,
  INDEX `fk_estadoDetalleOrden_has_detalleOdenCombo_detalleOdenCombo_idx` (`idDetalleOrdenCombo` ASC),
  INDEX `fk_estadoDetalleOrden_has_detalleOdenCombo_estadoDetalleOrd_idx` (`idEstadoDetalleOrden` ASC),
  INDEX `fk_bitacoraOdenCombo_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_estadoDetalleOrden_has_detalleOdenCombo_estadoDetalleOrden1`
    FOREIGN KEY (`idEstadoDetalleOrden`)
    REFERENCES `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_estadoDetalleOrden_has_detalleOdenCombo_detalleOdenCombo1`
    FOREIGN KEY (`idDetalleOrdenCombo`)
    REFERENCES `dbChurchill`.`detalleOrdenCombo` (`idDetalleOrdenCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_bitacoraOdenCombo_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`bitacoraEstadoCaja`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`bitacoraEstadoCaja` (
  `idCaja` INT NOT NULL,
  `idEstadoCaja` INT NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  PRIMARY KEY (`idCaja`, `idEstadoCaja`),
  INDEX `fk_caja_has_estadoCaja_estadoCaja1_idx` (`idEstadoCaja` ASC),
  INDEX `fk_caja_has_estadoCaja_caja1_idx` (`idCaja` ASC),
  INDEX `fk_bitacoraEstadoCaja_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_caja_has_estadoCaja_caja1`
    FOREIGN KEY (`idCaja`)
    REFERENCES `dbChurchill`.`caja` (`idCaja`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_caja_has_estadoCaja_estadoCaja1`
    FOREIGN KEY (`idEstadoCaja`)
    REFERENCES `dbChurchill`.`estadoCaja` (`idEstadoCaja`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_bitacoraEstadoCaja_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`reajusteCaja`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`reajusteCaja` (
  `idReajusteCaja` INT NOT NULL AUTO_INCREMENT,
  `idCaja` INT NOT NULL,
  `monto` DOUBLE(10,2) NOT NULL,
  `observacion` TEXT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  PRIMARY KEY (`idReajusteCaja`),
  INDEX `fk_reajusteCaja_caja1_idx` (`idCaja` ASC),
  INDEX `fk_reajusteCaja_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_reajusteCaja_caja1`
    FOREIGN KEY (`idCaja`)
    REFERENCES `dbChurchill`.`caja` (`idCaja`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_reajusteCaja_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`bitacoraEstadoFactura`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`bitacoraEstadoFactura` (
  `idFactura` INT NOT NULL,
  `idEstadoFactura` INT NOT NULL,
  `comentario` TEXT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  INDEX `fk_factura_has_estadoFactura_factura1_idx` (`idFactura` ASC),
  INDEX `fk_bitacoraEstadoFactura_usuario1_idx` (`usuario` ASC),
  INDEX `fk_bitacoraEstadoFactura_estadoFactura1_idx` (`idEstadoFactura` ASC),
  CONSTRAINT `fk_factura_has_estadoFactura_factura1`
    FOREIGN KEY (`idFactura`)
    REFERENCES `dbChurchill`.`factura` (`idFactura`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_bitacoraEstadoFactura_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_bitacoraEstadoFactura_estadoFactura1`
    FOREIGN KEY (`idEstadoFactura`)
    REFERENCES `dbChurchill`.`estadoFactura` (`idEstadoFactura`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`reajuste`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`reajuste` (
  `idReajuste` INT NOT NULL AUTO_INCREMENT,
  `observacion` TEXT NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  PRIMARY KEY (`idReajuste`),
  INDEX `fk_reajusteInventario_usuario2_idx` (`usuario` ASC),
  CONSTRAINT `fk_reajusteInventario_usuario2`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`reajusteProducto`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`reajusteProducto` (
  `idReajusteProducto` INT NOT NULL AUTO_INCREMENT,
  `idReajuste` INT NOT NULL,
  `idProducto` INT NOT NULL,
  `cantidad` DOUBLE(10,2) NOT NULL,
  `esIncremento` TINYINT(1) NOT NULL,
  PRIMARY KEY (`idReajusteProducto`),
  INDEX `fk_reajusteProducto_producto1_idx` (`idProducto` ASC),
  INDEX `fk_reajusteProducto_reajuste1_idx` (`idReajuste` ASC),
  UNIQUE INDEX `uq_reajuste_producto` (`idReajuste` ASC, `idProducto` ASC),
  CONSTRAINT `fk_reajusteProducto_producto1`
    FOREIGN KEY (`idProducto`)
    REFERENCES `dbChurchill`.`producto` (`idProducto`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_reajusteProducto_reajuste1`
    FOREIGN KEY (`idReajuste`)
    REFERENCES `dbChurchill`.`reajuste` (`idReajuste`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`detalleComboMenu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`detalleComboMenu` (
  `idDetalleOrdenMenu` INT NOT NULL,
  `idDetalleOrdenCombo` INT NOT NULL,
  PRIMARY KEY (`idDetalleOrdenMenu`, `idDetalleOrdenCombo`),
  INDEX `fk_detalleOrdenMenu_has_detalleOrdenCombo_detalleOrdenCombo_idx` (`idDetalleOrdenCombo` ASC),
  INDEX `fk_detalleOrdenMenu_has_detalleOrdenCombo_detalleOrdenMenu1_idx` (`idDetalleOrdenMenu` ASC),
  CONSTRAINT `fk_detalleOrdenMenu_has_detalleOrdenCombo_detalleOrdenMenu1`
    FOREIGN KEY (`idDetalleOrdenMenu`)
    REFERENCES `dbChurchill`.`detalleOrdenMenu` (`idDetalleOrdenMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOrdenMenu_has_detalleOrdenCombo_detalleOrdenCombo1`
    FOREIGN KEY (`idDetalleOrdenCombo`)
    REFERENCES `dbChurchill`.`detalleOrdenCombo` (`idDetalleOrdenCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`estadoCuadre`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`estadoCuadre` (
  `idEstadoCuadre` INT NOT NULL,
  `estadoCuadre` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idEstadoCuadre`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`cuadreProducto`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`cuadreProducto` (
  `idCuadreProducto` INT NOT NULL AUTO_INCREMENT,
  `fechaCuadre` DATE NOT NULL,
  `comentario` TEXT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `todos` TINYINT(1) NOT NULL,
  `idEstadoCuadre` INT NOT NULL,
  `idUbicacion` INT NOT NULL,
  PRIMARY KEY (`idCuadreProducto`),
  INDEX `fk_cierreDiario_usuario1_idx` (`usuario` ASC),
  INDEX `ix_fechaCierre` (`fechaCuadre` ASC),
  INDEX `fk_cierreDiario_estadoCuadre1_idx` (`idEstadoCuadre` ASC),
  INDEX `fk_cuadreProducto_ubicacion1_idx` (`idUbicacion` ASC),
  CONSTRAINT `fk_cierreDiario_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_cierreDiario_estadoCuadre1`
    FOREIGN KEY (`idEstadoCuadre`)
    REFERENCES `dbChurchill`.`estadoCuadre` (`idEstadoCuadre`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_cuadreProducto_ubicacion1`
    FOREIGN KEY (`idUbicacion`)
    REFERENCES `dbChurchill`.`ubicacion` (`idUbicacion`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`facturaCompraEstado`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`facturaCompraEstado` (
  `idFacturaCompra` INT NOT NULL,
  `idEstadoFactura` INT NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  INDEX `fk_facturaCompra_has_estadoFactura_estadoFactura1_idx` (`idEstadoFactura` ASC),
  INDEX `fk_facturaCompra_has_estadoFactura_facturaCompra1_idx` (`idFacturaCompra` ASC),
  INDEX `fk_facturaCompraEstado_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_facturaCompra_has_estadoFactura_facturaCompra1`
    FOREIGN KEY (`idFacturaCompra`)
    REFERENCES `dbChurchill`.`facturaCompra` (`idFacturaCompra`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_facturaCompra_has_estadoFactura_estadoFactura1`
    FOREIGN KEY (`idEstadoFactura`)
    REFERENCES `dbChurchill`.`estadoFactura` (`idEstadoFactura`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_facturaCompraEstado_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`formaPago`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`formaPago` (
  `idFormaPago` INT NOT NULL,
  `formaPago` VARCHAR(45) NOT NULL,
  `porcentajeRecargo` INT(2) NULL,
  `montoRecargo` DOUBLE(8,2) NULL,
  PRIMARY KEY (`idFormaPago`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`facturaFormaPago`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`facturaFormaPago` (
  `idFactura` INT NOT NULL,
  `idFormaPago` INT NOT NULL,
  `monto` DOUBLE(10,2) NOT NULL,
  PRIMARY KEY (`idFactura`, `idFormaPago`),
  INDEX `fk_factura_has_formaPago_formaPago1_idx` (`idFormaPago` ASC),
  INDEX `fk_factura_has_formaPago_factura1_idx` (`idFactura` ASC),
  CONSTRAINT `fk_factura_has_formaPago_factura1`
    FOREIGN KEY (`idFactura`)
    REFERENCES `dbChurchill`.`factura` (`idFactura`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_factura_has_formaPago_formaPago1`
    FOREIGN KEY (`idFormaPago`)
    REFERENCES `dbChurchill`.`formaPago` (`idFormaPago`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`menuPersonalizado`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`menuPersonalizado` (
  `idMenuPersonalizado` INT NOT NULL AUTO_INCREMENT,
  `idOrdenCliente` INT NOT NULL,
  `cantidad` INT NOT NULL,
  `descripcion` VARCHAR(125) NOT NULL,
  `precioUnidad` DOUBLE(10,2) NOT NULL,
  `observacion` TEXT NULL,
  `idEstadoDetalleOrden` INT NOT NULL DEFAULT 1,
  INDEX `fk_table1_ordenCliente1_idx` (`idOrdenCliente` ASC),
  PRIMARY KEY (`idMenuPersonalizado`),
  INDEX `fk_menuPersonalizado_estadoDetalleOrden1_idx` (`idEstadoDetalleOrden` ASC),
  CONSTRAINT `fk_table1_ordenCliente1`
    FOREIGN KEY (`idOrdenCliente`)
    REFERENCES `dbChurchill`.`ordenCliente` (`idOrdenCliente`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_menuPersonalizado_estadoDetalleOrden1`
    FOREIGN KEY (`idEstadoDetalleOrden`)
    REFERENCES `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`detalleOrdenFactura`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`detalleOrdenFactura` (
  `idFactura` INT NOT NULL,
  `idDetalleOrdenMenu` INT NULL,
  `idDetalleOrdenCombo` INT NULL,
  `idMenuPersonalizado` INT NULL,
  `precioMenu` DOUBLE(10,2) NOT NULL,
  `descuento` DOUBLE(10,2) NOT NULL,
  `comentario` TEXT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  INDEX `fk_detalleOrdenMenu_has_factura_factura1_idx` (`idFactura` ASC),
  INDEX `fk_detalleOrdenMenu_has_factura_detalleOrdenMenu1_idx` (`idDetalleOrdenMenu` ASC),
  INDEX `fk_detalleOrdenMenuFactura_usuario1_idx` (`usuario` ASC),
  INDEX `fk_detalleOrdenFactura_detalleOrdenCombo1_idx` (`idDetalleOrdenCombo` ASC),
  UNIQUE INDEX `uq_detalle` (`idFactura` ASC, `idDetalleOrdenMenu` ASC, `idDetalleOrdenCombo` ASC),
  INDEX `fk_detalleOrdenFactura_menuPersonalizado1_idx` (`idMenuPersonalizado` ASC),
  CONSTRAINT `fk_detalleOrdenMenu_has_factura_detalleOrdenMenu1`
    FOREIGN KEY (`idDetalleOrdenMenu`)
    REFERENCES `dbChurchill`.`detalleOrdenMenu` (`idDetalleOrdenMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOrdenMenu_has_factura_factura1`
    FOREIGN KEY (`idFactura`)
    REFERENCES `dbChurchill`.`factura` (`idFactura`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOrdenMenuFactura_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOrdenFactura_detalleOrdenCombo1`
    FOREIGN KEY (`idDetalleOrdenCombo`)
    REFERENCES `dbChurchill`.`detalleOrdenCombo` (`idDetalleOrdenCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_detalleOrdenFactura_menuPersonalizado1`
    FOREIGN KEY (`idMenuPersonalizado`)
    REFERENCES `dbChurchill`.`menuPersonalizado` (`idMenuPersonalizado`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`eventoMenu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`eventoMenu` (
  `idEventoMenu` INT NOT NULL AUTO_INCREMENT,
  `idEvento` INT NOT NULL,
  `idMenu` INT NOT NULL,
  `cantidad` INT NOT NULL,
  `horaDespacho` TIME NULL,
  `precioUnitario` DOUBLE(10,2) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `comentario` TEXT NULL,
  INDEX `fk_evento_has_menu_menu1_idx` (`idMenu` ASC),
  INDEX `fk_evento_has_menu_evento1_idx` (`idEvento` ASC),
  INDEX `fk_eventoMenu_usuario1_idx` (`usuario` ASC),
  PRIMARY KEY (`idEventoMenu`),
  CONSTRAINT `fk_evento_has_menu_evento1`
    FOREIGN KEY (`idEvento`)
    REFERENCES `dbChurchill`.`evento` (`idEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_evento_has_menu_menu1`
    FOREIGN KEY (`idMenu`)
    REFERENCES `dbChurchill`.`menu` (`idMenu`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_eventoMenu_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`eventoCombo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`eventoCombo` (
  `idEventoCombo` INT NOT NULL AUTO_INCREMENT,
  `idEvento` INT NOT NULL,
  `idCombo` INT NOT NULL,
  `cantidad` INT NOT NULL,
  `horaDespacho` TIME NULL,
  `precioUnitario` DOUBLE(10,2) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `comentario` TEXT NULL,
  INDEX `fk_combo_has_evento_evento1_idx` (`idEvento` ASC),
  INDEX `fk_combo_has_evento_combo1_idx` (`idCombo` ASC),
  INDEX `fk_eventoCombo_usuario1_idx` (`usuario` ASC),
  PRIMARY KEY (`idEventoCombo`),
  CONSTRAINT `fk_combo_has_evento_combo1`
    FOREIGN KEY (`idCombo`)
    REFERENCES `dbChurchill`.`combo` (`idCombo`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_combo_has_evento_evento1`
    FOREIGN KEY (`idEvento`)
    REFERENCES `dbChurchill`.`evento` (`idEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_eventoCombo_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`otroMenu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`otroMenu` (
  `idOtroMenu` INT NOT NULL AUTO_INCREMENT,
  `idEvento` INT NOT NULL,
  `otroMenu` VARCHAR(45) NOT NULL,
  `cantidad` INT NOT NULL,
  `horaDespacho` TIME NULL,
  `precioUnitario` DOUBLE(10,2) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `comentario` TEXT NULL,
  PRIMARY KEY (`idOtroMenu`),
  INDEX `fk_otroMenu_evento1_idx` (`idEvento` ASC),
  INDEX `fk_otroMenu_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_otroMenu_evento1`
    FOREIGN KEY (`idEvento`)
    REFERENCES `dbChurchill`.`evento` (`idEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_otroMenu_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`documento`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`documento` (
  `idDocumento` INT NOT NULL,
  `documento` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idDocumento`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`tipoItem`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`tipoItem` (
  `idTipoItem` INT NOT NULL,
  `tipoItem` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idTipoItem`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`documentoDetalle`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`documentoDetalle` (
  `idDocumentoDetalle` INT NOT NULL AUTO_INCREMENT,
  `idDocumento` INT NOT NULL,
  `idTipoItem` INT NOT NULL,
  `label` VARCHAR(45) NOT NULL,
  `_index` VARCHAR(25) NOT NULL,
  `x` INT NOT NULL,
  `y` INT NOT NULL,
  `mostrarTitulo` TINYINT(1) NOT NULL,
  `relativo` TINYINT(1) NOT NULL,
  `fontSize` INT NOT NULL,
  INDEX `fk_docDetalle_doc1_idx` (`idDocumento` ASC),
  INDEX `fk_docDetalle_tipoItem1_idx` (`idTipoItem` ASC),
  PRIMARY KEY (`idDocumentoDetalle`),
  CONSTRAINT `fk_docDetalle_doc1`
    FOREIGN KEY (`idDocumento`)
    REFERENCES `dbChurchill`.`documento` (`idDocumento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_docDetalle_tipoItem1`
    FOREIGN KEY (`idTipoItem`)
    REFERENCES `dbChurchill`.`tipoItem` (`idTipoItem`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`columnaLista`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`columnaLista` (
  `idColumnaLista` INT NOT NULL AUTO_INCREMENT,
  `idDocumentoDetalle` INT NOT NULL,
  `campo` VARCHAR(45) NOT NULL,
  `_index` VARCHAR(25) NOT NULL,
  `width` INT NOT NULL,
  `orden` INT NOT NULL,
  INDEX `fk_table1_documentoDetalle1_idx` (`idDocumentoDetalle` ASC),
  PRIMARY KEY (`idColumnaLista`),
  CONSTRAINT `fk_table1_documentoDetalle1`
    FOREIGN KEY (`idDocumentoDetalle`)
    REFERENCES `dbChurchill`.`documentoDetalle` (`idDocumentoDetalle`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`denominacion`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`denominacion` (
  `denominacion` DOUBLE(5,2) NOT NULL,
  `estado` TINYINT(1) NOT NULL,
  `descripcion` VARCHAR(15) NOT NULL,
  PRIMARY KEY (`denominacion`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`denominacionCaja`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`denominacionCaja` (
  `idCaja` INT NOT NULL,
  `idEstadoCaja` INT NOT NULL,
  `denominacion` DOUBLE(5,2) NOT NULL,
  `cantidad` INT NOT NULL,
  PRIMARY KEY (`idCaja`, `idEstadoCaja`, `denominacion`),
  INDEX `fk_bitacoraEstadoCaja_has_denominacion_bitacoraEstadoCaja1_idx` (`idCaja` ASC, `idEstadoCaja` ASC),
  INDEX `fk_denominacionCaja_denominacion1_idx` (`denominacion` ASC),
  CONSTRAINT `fk_bitacoraEstadoCaja_has_denominacion_bitacoraEstadoCaja1`
    FOREIGN KEY (`idCaja` , `idEstadoCaja`)
    REFERENCES `dbChurchill`.`bitacoraEstadoCaja` (`idCaja` , `idEstadoCaja`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_denominacionCaja_denominacion1`
    FOREIGN KEY (`denominacion`)
    REFERENCES `dbChurchill`.`denominacion` (`denominacion`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`estadoMovimiento`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`estadoMovimiento` (
  `idEstadoMovimiento` INT NOT NULL,
  `estadoMovimiento` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`idEstadoMovimiento`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`tipoMovimiento`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`tipoMovimiento` (
  `idTipoMovimiento` INT NOT NULL,
  `tipoMovimiento` VARCHAR(45) NOT NULL,
  `ingreso` TINYINT(1) NOT NULL,
  PRIMARY KEY (`idTipoMovimiento`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`movimiento`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`movimiento` (
  `idMovimiento` INT NOT NULL AUTO_INCREMENT,
  `idCaja` INT NOT NULL,
  `idTipoMovimiento` INT NOT NULL,
  `idEstadoMovimiento` INT NOT NULL,
  `idFormaPago` INT NOT NULL,
  `idEvento` INT NULL,
  `motivo` VARCHAR(60) NOT NULL,
  `monto` DOUBLE(10,2) NOT NULL,
  PRIMARY KEY (`idMovimiento`),
  INDEX `fk_ingresoEgreso_caja1_idx` (`idCaja` ASC),
  INDEX `fk_ingresoEgreso_estadoMovimiento1_idx` (`idEstadoMovimiento` ASC),
  INDEX `fk_movimiento_evento1_idx` (`idEvento` ASC),
  INDEX `fk_movimiento_formaPago1_idx` (`idFormaPago` ASC),
  INDEX `fk_movimiento_tipoMovimiento1_idx` (`idTipoMovimiento` ASC),
  CONSTRAINT `fk_ingresoEgreso_caja1`
    FOREIGN KEY (`idCaja`)
    REFERENCES `dbChurchill`.`caja` (`idCaja`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_ingresoEgreso_estadoMovimiento1`
    FOREIGN KEY (`idEstadoMovimiento`)
    REFERENCES `dbChurchill`.`estadoMovimiento` (`idEstadoMovimiento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_movimiento_evento1`
    FOREIGN KEY (`idEvento`)
    REFERENCES `dbChurchill`.`evento` (`idEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_movimiento_formaPago1`
    FOREIGN KEY (`idFormaPago`)
    REFERENCES `dbChurchill`.`formaPago` (`idFormaPago`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_movimiento_tipoMovimiento1`
    FOREIGN KEY (`idTipoMovimiento`)
    REFERENCES `dbChurchill`.`tipoMovimiento` (`idTipoMovimiento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`logEstadoMovimiento`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`logEstadoMovimiento` (
  `idMovimiento` INT NOT NULL,
  `idEstadoMovimiento` INT NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `comentario` TEXT NULL,
  PRIMARY KEY (`idMovimiento`, `idEstadoMovimiento`),
  INDEX `fk_movimiento_has_estadoMovimiento_estadoMovimiento1_idx` (`idEstadoMovimiento` ASC),
  INDEX `fk_movimiento_has_estadoMovimiento_movimiento1_idx` (`idMovimiento` ASC),
  INDEX `fk_logEstadoMovimiento_usuario1_idx` (`usuario` ASC),
  CONSTRAINT `fk_movimiento_has_estadoMovimiento_movimiento1`
    FOREIGN KEY (`idMovimiento`)
    REFERENCES `dbChurchill`.`movimiento` (`idMovimiento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_movimiento_has_estadoMovimiento_estadoMovimiento1`
    FOREIGN KEY (`idEstadoMovimiento`)
    REFERENCES `dbChurchill`.`estadoMovimiento` (`idEstadoMovimiento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_logEstadoMovimiento_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`otroServicio`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`otroServicio` (
  `idOtroServicio` INT NOT NULL AUTO_INCREMENT,
  `idEvento` INT NOT NULL,
  `otroServicio` VARCHAR(45) NOT NULL,
  `cantidad` DOUBLE(8,2) NOT NULL,
  `precioUnitario` DOUBLE(10,2) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  `usuario` VARCHAR(15) NOT NULL,
  `comentario` TEXT NULL,
  PRIMARY KEY (`idOtroServicio`),
  INDEX `fk_otroServicio_usuario1_idx` (`usuario` ASC),
  INDEX `fk_otroServicio_evento1_idx` (`idEvento` ASC),
  CONSTRAINT `fk_otroServicio_usuario1`
    FOREIGN KEY (`usuario`)
    REFERENCES `dbChurchill`.`usuario` (`usuario`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_otroServicio_evento1`
    FOREIGN KEY (`idEvento`)
    REFERENCES `dbChurchill`.`evento` (`idEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`eventoFactura`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`eventoFactura` (
  `idEventoFactura` INT NOT NULL AUTO_INCREMENT,
  `idEvento` INT NOT NULL,
  `idFactura` INT NOT NULL,
  `cantidad` INT NOT NULL,
  `descripcion` TEXT NOT NULL,
  `subTotal` DOUBLE(10,2) NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  INDEX `fk_evento_has_factura_factura1_idx` (`idFactura` ASC),
  INDEX `fk_evento_has_factura_evento1_idx` (`idEvento` ASC),
  PRIMARY KEY (`idEventoFactura`),
  CONSTRAINT `fk_evento_has_factura_evento1`
    FOREIGN KEY (`idEvento`)
    REFERENCES `dbChurchill`.`evento` (`idEvento`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_evento_has_factura_factura1`
    FOREIGN KEY (`idFactura`)
    REFERENCES `dbChurchill`.`factura` (`idFactura`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`bitacoraEstadoCierre`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`bitacoraEstadoCierre` (
  `idEstadoCuadre` INT NOT NULL,
  `idCuadreProducto` INT NOT NULL,
  `fechaRegistro` DATETIME NOT NULL,
  PRIMARY KEY (`idEstadoCuadre`, `idCuadreProducto`),
  INDEX `fk_bitacoraEstadoCierre_estadoCuadre1_idx` (`idEstadoCuadre` ASC),
  INDEX `fk_bitacoraEstadoCierre_cuadreProducto1_idx` (`idCuadreProducto` ASC),
  CONSTRAINT `fk_bitacoraEstadoCierre_estadoCuadre1`
    FOREIGN KEY (`idEstadoCuadre`)
    REFERENCES `dbChurchill`.`estadoCuadre` (`idEstadoCuadre`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_bitacoraEstadoCierre_cuadreProducto1`
    FOREIGN KEY (`idCuadreProducto`)
    REFERENCES `dbChurchill`.`cuadreProducto` (`idCuadreProducto`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`cuadreProductoDetalle`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`cuadreProductoDetalle` (
  `idCuadreProducto` INT NOT NULL,
  `idProducto` INT NOT NULL,
  `cantidadApertura` DOUBLE(10,2) NOT NULL,
  `cantidadCierre` DOUBLE(10,2) NOT NULL,
  `diferenciaApertura` DOUBLE(10,2) NULL,
  `diferenciaCierre` DOUBLE(10,2) NULL,
  `comentarioApertura` TEXT NULL,
  `comentarioCierre` TEXT NULL,
  PRIMARY KEY (`idCuadreProducto`, `idProducto`),
  INDEX `fk_cuadreProducto_has_producto_producto1_idx` (`idProducto` ASC),
  INDEX `fk_cuadreProducto_has_producto_cuadreProducto1_idx` (`idCuadreProducto` ASC),
  CONSTRAINT `fk_cuadreProducto_has_producto_cuadreProducto1`
    FOREIGN KEY (`idCuadreProducto`)
    REFERENCES `dbChurchill`.`cuadreProducto` (`idCuadreProducto`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_cuadreProducto_has_producto_producto1`
    FOREIGN KEY (`idProducto`)
    REFERENCES `dbChurchill`.`producto` (`idProducto`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `dbChurchill`.`parametro`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`parametro` (
  `idParametro` VARCHAR(20) NOT NULL,
  `parametro` VARCHAR(45) NOT NULL,
  `valor` VARCHAR(200) NOT NULL,
  PRIMARY KEY (`idParametro`))
ENGINE = InnoDB;

USE `dbChurchill` ;

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vstCliente`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vstCliente` (`idCliente` INT, `nit` INT, `nombre` INT, `cui` INT, `correo` INT, `telefono` INT, `direccion` INT, `idTipoCliente` INT, `tipoCliente` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstProducto`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstProducto` (`idProducto` INT, `producto` INT, `idMedida` INT, `medida` INT, `idTipoProducto` INT, `tipoProducto` INT, `perecedero` INT, `cantidadMinima` INT, `cantidadMaxima` INT, `disponibilidad` INT, `importante` INT, `idUbicacion` INT, `ubicacion` INT, `'usuarioProducto'` INT, `'fechaProducto'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstIngresoProducto`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstIngresoProducto` (`idIngreso` INT, `idFacturaCompra` INT, `idProducto` INT, `producto` INT, `idMedida` INT, `medida` INT, `idTipoProducto` INT, `tipoProducto` INT, `perecedero` INT, `cantidadMinima` INT, `cantidadMaxima` INT, `disponibilidad` INT, `importante` INT, `cantidad` INT, `costo` INT, `'usuarioIngreso'` INT, `'fechaIngreso'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstReajusteProducto`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstReajusteProducto` (`idReajuste` INT, `idProducto` INT, `producto` INT, `idMedida` INT, `medida` INT, `idTipoProducto` INT, `tipoProducto` INT, `perecedero` INT, `cantidadMinima` INT, `cantidadMaxima` INT, `disponibilidad` INT, `importante` INT, `cantidad` INT, `esIncremento` INT, `observacion` INT, `'usuarioReajuste'` INT, `'fechaReajuste'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstMenu`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstMenu` (`idMenu` INT, `menu` INT, `'imagen'` INT, `descripcion` INT, `idEstadoMenu` INT, `estadoMenu` INT, `idDestinoMenu` INT, `destinoMenu` INT, `idTipoMenu` INT, `tipoMenu` INT, `'codigoMenu'` INT, `tiempoAlerta` INT, `seCocina` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstReceta`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstReceta` (`idMenu` INT, `idProducto` INT, `producto` INT, `cantidad` INT, `medida` INT, `tipoProducto` INT, `observacion` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstMenuPrecio`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstMenuPrecio` (`idMenu` INT, `precio` INT, `idTipoServicio` INT, `tipoServicio` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstCombo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstCombo` (`idCombo` INT, `combo` INT, `'imagen'` INT, `descripcion` INT, `idEstadoMenu` INT, `estadoMenu` INT, `'codigoCombo'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstComboDetalle`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstComboDetalle` (`idCombo` INT, `cantidad` INT, `idMenu` INT, `menu` INT, `imagen` INT, `descripcion` INT, `idEstadoMenu` INT, `estadoMenu` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstComboPrecio`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstComboPrecio` (`idCombo` INT, `precio` INT, `idTipoServicio` INT, `tipoServicio` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstSuperCombo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstSuperCombo` (`idSuperCombo` INT, `superCombo` INT, `'imagen'` INT, `descripcion` INT, `idEstadoMenu` INT, `estadoMenu` INT, `'codigoSuperCombo'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstSuperComboDetalle`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstSuperComboDetalle` (`idSuperCombo` INT, `cantidad` INT, `idCombo` INT, `combo` INT, `imagen` INT, `descripcion` INT, `idEstadoMenu` INT, `estadoMenu` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstSuperComboPrecio`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstSuperComboPrecio` (`idSuperCombo` INT, `precio` INT, `idTipoServicio` INT, `tipoServicio` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`_vMenuCombo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`_vMenuCombo` (`idDetalleOrdenMenu` INT, `idDetalleOrdenCombo` INT, `'precioCombo'` INT, `combo` INT, `idCombo` INT, `'imagenCombo'` INT, `'idEstadoDetalleOrdenCombo'` INT, `'observacionCombo'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vOrdenes`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vOrdenes` (`idDetalleOrdenMenu` INT, `idOrdenCliente` INT, `numeroTicket` INT, `'responsableOrden'` INT, `idEstadoOrden` INT, `numeroGrupo` INT, `cantidad` INT, `idMenu` INT, `menu` INT, `'codigoMenu'` INT, `tiempoAlerta` INT, `perteneceCombo` INT, `descripcion` INT, `'imagen'` INT, `precio` INT, `idCombo` INT, `combo` INT, `imagenCombo` INT, `precioCombo` INT, `idEstadoDetalleOrden` INT, `estadoDetalleOrden` INT, `idTipoServicio` INT, `tipoServicio` INT, `idDestinoMenu` INT, `destinoMenu` INT, `'responsableDetalle'` INT, `'usuarioDetalle'` INT, `observacion` INT, `nombres` INT, `codigo` INT, `idDetalleOrdenCombo` INT, `idEstadoDetalleOrdenCombo` INT, `fechaRegistro` INT, `'usuarioRegistro'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vOrdenCliente`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vOrdenCliente` (`idOrdenCliente` INT, `numeroTicket` INT, `usuarioPropietario` INT, `usuarioResponsable` INT, `idEstadoOrden` INT, `estadoOrden` INT, `fechaRegistro` INT, `numMenu` INT, `numeroGrupo` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vCuadreProducto`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vCuadreProducto` (`idCuadreProducto` INT, `fechaCuadre` INT, `comentario` INT, `usuario` INT, `'fechaRegistroCuadre'` INT, `todos` INT, `idUbicacion` INT, `ubicacion` INT, `idEstadoCuadre` INT, `estadoCuadre` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vCuadreProductoDetalle`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vCuadreProductoDetalle` (`idCuadreProducto` INT, `fechaCuadre` INT, `comentario` INT, `usuario` INT, `fechaRegistroCuadre` INT, `cantidadApertura` INT, `cantidadCierre` INT, `diferenciaApertura` INT, `diferenciaCierre` INT, `comentarioApertura` INT, `comentarioCierre` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`lstFacturaCompra`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`lstFacturaCompra` (`idFacturaCompra` INT, `noFactura` INT, `proveedor` INT, `fechaFactura` INT, `comentario` INT, `idEstadoFactura` INT, `estadoFactura` INT, `usuario` INT, `fechaRegistro` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vUsuario`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vUsuario` (`usuario` INT, `codigo` INT, `nombres` INT, `apellidos` INT, `fechaRegistro` INT, `idEstadoUsuario` INT, `estadoUsuario` INT, `idPerfil` INT, `perfil` INT, `idDestinoMenu` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vstCaja`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vstCaja` (`idCaja` INT, `usuario` INT, `fechaApertura` INT, `efectivoInicial` INT, `efectivoFinal` INT, `efectivoSobrante` INT, `efectivoFaltante` INT, `idEstadoCaja` INT, `estadoCaja` INT, `nombres` INT, `apellidos` INT, `codigo` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vstFactura`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vstFactura` (`idFactura` INT, `idCliente` INT, `nit` INT, `idCaja` INT, `nombre` INT, `direccion` INT, `total` INT, `fechaFactura` INT, `usuario` INT, `idEstadoFactura` INT, `estadoFactura` INT, `fechaRegistro` INT, `descripcion` INT, `'siDetalle'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vstFormaPago`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vstFormaPago` (`idFactura` INT, `monto` INT, `idFormaPago` INT, `formaPago` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vstDetalleOrdenFactura`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vstDetalleOrdenFactura` (`idFactura` INT, `idOrdenCliente` INT, `numeroTicket` INT, `idDetalleOrdenMenu` INT, `idMenu` INT, `menu` INT, `imagen` INT, `perteneceCombo` INT, `idDetalleOrdenCombo` INT, `idCombo` INT, `combo` INT, `imagenCombo` INT, `idTipoServicio` INT, `tipoServicio` INT, `usuarioRegistro` INT, `precioMenu` INT, `descuento` INT, `'precioReal'` INT, `comentario` INT, `'usuarioFacturaDetalle'` INT, `'fechaFacturaDetalle'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vEvento`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vEvento` (`idEvento` INT, `evento` INT, `fechaEvento` INT, `idSalon` INT, `salon` INT, `horaInicio` INT, `horaFinal` INT, `observacion` INT, `usuario` INT, `fechaRegistro` INT, `numeroPersonas` INT, `idEstadoEvento` INT, `estadoEvento` INT, `idCliente` INT, `nit` INT, `nombre` INT, `cui` INT, `correo` INT, `telefono` INT, `direccion` INT, `idTipoCliente` INT, `tipoCliente` INT, `idFactura` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vDenominacionCaja`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vDenominacionCaja` (`idCaja` INT, `idEstadoCaja` INT, `denominacion` INT, `cantidad` INT, `'monto'` INT);

-- -----------------------------------------------------
-- Placeholder table for view `dbChurchill`.`vOtroServicio`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `dbChurchill`.`vOtroServicio` (`idOtroServicio` INT, `idEvento` INT, `otroServicio` INT, `cantidad` INT, `precioUnitario` INT, `fechaRegistro` INT, `usuario` INT);

-- -----------------------------------------------------
-- procedure consultaUsuario
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaUsuario( _action VARCHAR(15), _usuario varchar(15), _codigo INT(4), _nombres VARCHAR(65), _apellidos VARCHAR(65), _idPerfil INT, _idDestinoMenu INT )
BEGIN

	# IF DUPLICATE
	DECLARE EXIT HANDLER FOR 1062
		SELECT 'danger' AS 'respuesta', 'Usuario o Código Duplicado' AS 'mensaje';

    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';
    
	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO usuario
			(usuario, codigo, clave, nombres, apellidos, fechaRegistro, idEstadoUsuario, idPerfil, usuarioRegistro, idDestinoMenu ) 
		VALUES
			(_usuario, _codigo, _usuario, _nombres, _apellidos, now(), 1, _idPerfil, @usuario, _idDestinoMenu );
			
		INSERT INTO log_estadoUsuario (idEstadoUsuario, usuario, usuarioRegistro, fechaRegistro)
		VALUES (1, _usuario, @usuario, now());
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
	
    ELSEIF _action = 'update' THEN
		UPDATE usuario SET
			codigo 		  = _codigo,
            nombres 	  = _nombres,
            apellidos 	  = _apellidos,
            idPerfil 	  = _idPerfil,
            idDestinoMenu = _idDestinoMenu
		WHERE usuario = _usuario;
    
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
    
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
end$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure actualizarEstadoUsuario
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE actualizarEstadoUsuario( _usuario varchar(15), _idEstadoUsuario INT )
BEGIN
	DECLARE EXIT HANDLER FOR 1452
        SELECT 'danger' AS 'respuesta', 'Dato No Existe' AS 'mensaje';

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF sesionValida() THEN
        IF _usuario != @usuario THEN
			UPDATE usuario SET idEstadoUsuario = _idEstadoUsuario where usuario = _usuario;
			
			INSERT INTO log_estadoUsuario (idEstadoUsuario, usuario, usuarioRegistro, fechaRegistro)
			VALUES (1, _usuario, @usuario, now());
            
            SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
            
		ELSE
			SELECT 'warning' AS 'respuesta', 'No es posible cambiar el estado a su propio usuario' AS 'mensaje';
		END IF;
    
    ELSE
		SELECT 'danger' AS 'respuesta', 'Sesión no válida o acceso denegado' AS 'mensaje';
    END IF;
end$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure login
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE login( _usuario varchar(15), _clave varchar(75), _codigo INT )
BEGIN
	# DECLARE VARS
	DECLARE _sesionValida int default 0;
    DECLARE _nombre varchar(90) default '';
    DECLARE _nombreCorto varchar(35) default '';
    DECLARE _idPerfil INT;
    DECLARE _idDestinoMenu INT;
    DECLARE _codigoUsuario INT;

    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';
	END;
    
    # VALIDATE USER&PASSWORD
    SELECT 
		IF( idEstadoUsuario = 1, 1, -1 ), usuario, CONCAT(nombres, ' ', apellidos), idPerfil, codigo, nombres, idDestinoMenu
			INTO 
        _sesionValida, _usuario, _nombre, _idPerfil, _codigoUsuario, _nombreCorto, _idDestinoMenu
	FROM usuario 
    WHERE IF( ISNULL( _codigo ), usuario = _usuario, codigo = _codigo ) 
		AND clave = md5( _clave );
    
    # IF SESSION IS VALID
    IF _sesionValida = 1 THEN
		IF _usuario = _clave THEN
			SELECT 'warning' AS 'respuesta', 'Debe de Cambiar su Contraseña antes de ingresar' AS 'mensaje';
		ELSE
			SELECT 'success' AS 'respuesta', 'Autenticado correctamente' AS 'mensaje', _nombre AS 'nombre', 
				_idPerfil AS 'idPerfil', _codigoUsuario AS 'codigoUsuario', _nombreCorto AS 'nombreCorto', _usuario AS 'usuario', _idDestinoMenu AS 'idDestinoMenu';

			INSERT INTO historialAutenticacion (usuario, fechaRegistro, idTipoRespuesta) 
				VALUES(_usuario, now(), 1);
        END IF;
	# IF SESSION IS VALID
    ELSEIF _sesionValida = -1 THEN
		SELECT 'danger' AS 'respuesta', 'Usuario Bloqueado' AS 'mensaje';
        INSERT INTO historialAutenticacion (usuario, fechaRegistro, idTipoRespuesta) 
			VALUES(_usuario, now(), 3);
	# IF SESSION IS NOT VALID
    ELSE
		SELECT 'danger' AS 'respuesta', 'Usuario/Password no valido' AS 'mensaje';
    END IF;
end$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure cambiarClaveUsuario
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE cambiarClaveUsuario(_usuario varchar(15), _clave varchar(75), _nuevaClave varchar(75))
BEGIN
	# DECLARE VARS
	DECLARE claveAnteriorValida INT DEFAULT 0;
    
    # VALIDATE USER&PASSWORD
    SELECT 1 INTO claveAnteriorValida
		FROM usuario WHERE usuario = _usuario AND clave = md5( _clave );
    
    # IF SESSION IS VALID
    IF claveAnteriorValida = 1 THEN
		UPDATE usuario SET clave = md5( _nuevaClave ) 
			WHERE usuario = _usuario;
            
        SELECT 'success' AS 'respuesta', 'Realizado correctamente' AS 'mensaje';
    ELSE
		SELECT 'danger' AS 'respuesta', 'Clave anterior no válida' AS 'mensaje';
    END IF;
end$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure resetearClave
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE resetearClave( _usuario varchar(15) )
BEGIN
	IF sesionValida() THEN    
		UPDATE usuario SET clave = md5( _usuario ) where usuario = _usuario;

		SELECT 'success' AS 'respuesta', 'Usuario reseteado correctamente' AS 'mensaje';
        
    ELSE
		SELECT 'danger' AS 'respuesta', 'Sesión no válida o acceso denegado' AS 'mensaje';
    END IF;
end$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure clienteNuevo
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE clienteNuevo( _nit VARCHAR(15), _nombre VARCHAR(65), _cui VARCHAR(13), 
	_correo VARCHAR(65), _telefono VARCHAR(8),  _direccion VARCHAR(95), _idTipoCliente INT )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
        SELECT 'danger' AS 'respuesta', 'Error, NIT duplicado' AS 'mensaje';
    
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
    IF sesionValida() THEN
		INSERT INTO cliente ( nit, nombre, cui, correo, telefono, direccion, idTipoCliente, fechaRegistro, usuario ) 
			VALUES ( _nit, _nombre, _cui, _correo, _telefono, _direccion, _idTipoCliente, now(), @usuario );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', last_insert_id() AS 'id';
    ELSE
		SELECT 'danger' AS 'respuesta', 'Error sesión no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure clienteActualizar
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE clienteActualizar( _idCliente INT, _nit VARCHAR(15), _nombre VARCHAR(65), _cui VARCHAR(13), 
	_correo VARCHAR(65), _telefono VARCHAR(8),  _direccion VARCHAR(95), _idTipoCliente INT )
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
	IF sesionValida() THEN
		UPDATE cliente SET
			nit 		= _nit, 
			nombre 		= _nombre, 
			cui 		= _cui, 
			correo 		= _correo, 
			telefono 	= _telefono,
			direccion 	= _direccion,
			idTipoCliente = _idTipoCliente
		WHERE idCliente = _idCliente;
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
    ELSE
		SELECT 'danger' AS 'respuesta', 'Error sesión no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure inicioSesion
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE inicioSesion( _usuario varchar(15) )
BEGIN
	
    SET @usuario = NULL, @idNivel = NULL, @idPerfil = NULL;
    
    SELECT usuario, idNivel, idPerfil INTO @usuario, @idNivel, @idPerfil 
		FROM usuario WHERE usuario = _usuario AND idEstadoUsuario = 1;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- function sesionValida
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE FUNCTION sesionValida() RETURNS BOOLEAN
BEGIN
	IF !ISNULL( @usuario ) AND !ISNULL( @idPerfil ) THEN
		RETURN TRUE;
    ELSE
		RETURN FALSE;
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure definirSesion
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE definirSesion( _usuario varchar(15) )
BEGIN
	
    SET @usuario = NULL, @idPerfil = NULL, @isAdmin = NULL, @idDestinoMenu= NULL;
    
    SELECT usuario, idPerfil, idDestinoMenu, IF( idPerfil = 1, TRUE, FALSE ) 
		INTO @usuario, @idPerfil, @idDestinoMenu, @isAdmin
	FROM usuario WHERE usuario = _usuario AND idEstadoUsuario = 1;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaCliente
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaCliente( _action VARCHAR(15), _idCliente INT, _nit VARCHAR(15), _nombre VARCHAR(65), _cui VARCHAR(13), 
	_correo VARCHAR(65), _telefono VARCHAR(8),  _direccion VARCHAR(95), _idTipoCliente INT )
BEGIN
	DECLARE _existeCliente BOOLEAN DEFAULT FALSE;
    
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
    
    IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		SELECT TRUE INTO _existeCliente FROM cliente WHERE nit = _nit AND LENGTH( nit ) > 2 LIMIT 1;
        
        IF _existeCliente THEN
			SELECT 'danger' AS 'respuesta', 'Error, NIT duplicado' AS 'mensaje';
		
        ELSE
			INSERT INTO cliente ( nit, nombre, cui, correo, telefono, direccion, idTipoCliente, fechaRegistro, usuario ) 
				VALUES ( _nit, _nombre, _cui, _correo, _telefono, _direccion, _idTipoCliente, now(), @usuario );
                
			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', last_insert_id() AS 'id';
        END IF;
    ELSEIF _action = 'update' THEN
		SELECT TRUE INTO _existeCliente FROM cliente 
			WHERE idCliente != _idCliente AND nit = _nit AND LENGTH( nit ) > 2 LIMIT 1;
        
		IF _existeCliente THEN
			SELECT 'danger' AS 'respuesta', 'Error, NIT ya pertenece a otro cliente' AS 'mensaje';
		
        ELSEIF _idCliente = 1 THEN
			SELECT 'danger' AS 'respuesta', 'No es posible modificar este cliente' AS 'mensaje';
            
        ELSE
			UPDATE cliente SET
				nit 		= _nit, 
				nombre 		= _nombre, 
				cui 		= _cui, 
				correo 		= _correo, 
				telefono 	= _telefono,
				direccion 	= _direccion,
				idTipoCliente = _idTipoCliente
			WHERE idCliente = _idCliente;
			
			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
        END IF;
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure guardarProducto
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE guardarProducto( _producto VARCHAR(45), _idTipoProducto INT, _idMedida INT, 
	_perecedero BOOLEAN, _cantidadMinima DOUBLE(10,2), _cantidadMaxima DOUBLE(10,2), _disponibilidad DOUBLE(10,2), _importante BOOLEAN )
BEGIN

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';
    
	IF sesionValida() THEN
		INSERT INTO producto
		(producto, idTipoProducto, idMedida, perecedero, cantidadMinima, cantidadMaxima, disponibilidad, 
			importante, fechaRegistro, usuario)
        VALUES
		(_producto, _idTipoProducto, _idMedida, _perecedero, _cantidadMinima, _cantidadMaxima, _disponibilidad, 
			_importante, NOW(), @usuario);
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaProducto
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaProducto( _action VARCHAR(20), _idProducto INT, _producto VARCHAR(45), _idTipoProducto INT, _idMedida INT, _perecedero BOOLEAN, _cantidadMinima DOUBLE(10,2), _cantidadMaxima DOUBLE(10,2), _disponibilidad DOUBLE(10,2), _importante BOOLEAN, _idUbicacion CHAR(1) )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
		SELECT 'danger' AS 'respuesta', 'Error, producto duplicado' AS 'mensaje';

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';


	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO producto ( producto, idTipoProducto, idMedida, perecedero, cantidadMinima, cantidadMaxima, disponibilidad, importante, idUbicacion, fechaRegistro, usuario )
			VALUES ( _producto, _idTipoProducto, _idMedida, _perecedero, _cantidadMinima, _cantidadMaxima, _disponibilidad, _importante, _idUbicacion, NOW(), @usuario );
		
        SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';

	ELSEIF _action = 'update' THEN
		UPDATE producto SET 
			producto       = _producto, 
			idTipoProducto = _idTipoProducto, 
            idUbicacion    = _idUbicacion,
			idMedida       = _idMedida, 
			perecedero     = _perecedero, 
			cantidadMinima = _cantidadMinima, 
			cantidadMaxima = _cantidadMaxima,
			importante     = _importante,
            idUbicacion    = _idUbicacion
		WHERE idProducto = _idProducto;
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaMedida
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaMedida( _action VARCHAR(20), _idMedida INT, _medida VARCHAR(45) )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
		SELECT 'danger' AS 'respuesta', 'Medida duplicada' AS 'mensaje';

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO medida VALUES ( _idMedida, _medida );
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';

	ELSEIF _action = 'update' THEN
		UPDATE medida  SET medida = _medida
			WHERE idMedida = _idMedida;
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaTipoProducto
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaTipoProducto( _action VARCHAR(20), _idTipoProducto INT, _tipoProducto VARCHAR(45) )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
		SELECT 'danger' AS 'respuesta', 'Tipo de Producto duplicado' AS 'mensaje';

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO tipoProducto VALUES ( _idTipoProducto, _tipoProducto );
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';

	ELSEIF _action = 'update' THEN
		UPDATE tipoProducto  SET tipoProducto = _tipoProducto
			WHERE idTipoProducto = _idTipoProducto;
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaIngreso
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaIngreso( _action VARCHAR(20), _idIngreso INT, _cantidad DOUBLE(10,2), _costo DOUBLE(12,2), _idProducto INT, _idFacturaCompra INT )
BEGIN

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';


	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO ingreso ( idFacturaCompra, idProducto, cantidad, costo, usuario, fechaRegistro ) 
			VALUES ( _idFacturaCompra, _idProducto, _cantidad, _costo, @usuario, NOW() );
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'delete' THEN
		DELETE FROM ingreso WHERE idIngreso = _idIngreso;
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaReajusteInventario
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaReajusteInventario( _action VARCHAR(20), _idProducto INT, _cantidad DOUBLE(10,2), _observacion TEXT, _esIncremento BOOLEAN )
BEGIN
	DECLARE _disponibilidad DOUBLE(10,2);

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		SELECT disponibilidad INTO _disponibilidad FROM producto WHERE idProducto = _idProducto;

		IF ! _esIncremento AND _disponibilidad < _cantidad THEN
			SELECT 'danger' AS 'respuesta', 'La disponibilidad no puede ser menor a cero' AS 'mensaje';

		ELSE
			INSERT INTO reajusteInventario (idProducto, cantidad, observacion, esIncremento, usuario, fechaRegistro) 
				VALUES ( _idProducto, _cantidad, _observacion, _esIncremento, @usuario, NOW() );
			
			IF _esIncremento THEN
				UPDATE producto SET disponibilidad = disponibilidad + _cantidad
					WHERE idProducto = _idProducto;
			ELSE
				UPDATE producto SET disponibilidad = disponibilidad - _cantidad
					WHERE idProducto = _idProducto;
			END IF;

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
		END IF;
	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaMenu
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaMenu( _action VARCHAR(20), _idMenu INT, _menu VARCHAR(45), _imagen VARCHAR(125), _descripcion TEXT, 
	_idEstadoMenu INT, _idDestinoMenu INT, _idTipoMenu INT, _codigo INT, _tiempoAlerta INT, _seCocina BOOLEAN )
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';


	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		IF ! codigoDuplicado( _codigo, NULL, NULL, NULL ) THEN
			SELECT 'danger' AS 'respuesta', 'Código rápido ya pertenece a otro menú' AS 'mensaje';
        
        ELSE
			INSERT INTO menu ( menu, imagen, descripcion, idEstadoMenu, idDestinoMenu, top, idTipoMenu, codigo, tiempoAlerta, seCocina ) 
				VALUES ( _menu, _imagen, _descripcion, _idEstadoMenu, _idDestinoMenu, 0, _idTipoMenu, _codigo, _tiempoAlerta, _seCocina );

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
        END IF;

	ELSEIF _action = 'update' THEN
		IF ! codigoDuplicado( _codigo, _idMenu, NULL, NULL ) THEN
			SELECT 'danger' AS 'respuesta', 'Código rápido ya pertenece a otro menú' AS 'mensaje';
            
        ELSE
			UPDATE menu SET 
				menu          = _menu, 
				descripcion   = _descripcion, 
				idEstadoMenu  = _idEstadoMenu, 
				idDestinoMenu = _idDestinoMenu,
				idTipoMenu    = _idTipoMenu,
				codigo 		  = _codigo,
                tiempoAlerta  = _tiempoAlerta,
                seCocina 	  = _seCocina
			WHERE idMenu = _idMenu;
			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
        END IF;
	
    ELSEIF _action = 'image' THEN
		UPDATE menu SET imagen = _imagen WHERE idMenu = _idMenu;
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
        
	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaReceta
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaReceta( _action VARCHAR(20), _idMenu INT, _idProducto INT, _cantidad DOUBLE(10,2), _observacion TEXT )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
		SELECT 'danger' AS 'respuesta', 'Error, el producto ya existe en el menú ' AS 'mensaje';

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';


	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO receta ( idMenu, idProducto, cantidad, observacion ) 
			VALUES ( _idMenu, _idProducto, _cantidad, _observacion );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'update' THEN
		UPDATE receta SET 
			cantidad    = _cantidad,
			observacion = _observacion
		WHERE idMenu = _idMenu AND idProducto = _idProducto;
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
	
    ELSEIF _action = 'delete' THEN
		DELETE FROM receta WHERE idMenu = _idMenu AND idProducto = _idProducto;
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaCombo
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaCombo( _action VARCHAR(20), _idCombo INT, _combo VARCHAR(45), _imagen VARCHAR(125), _descripcion TEXT, _idEstadoMenu INT, _codigo INT )
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';


	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		IF ! codigoDuplicado( _codigo, NULL, NULL, NULL ) THEN
			SELECT 'danger' AS 'respuesta', 'Código rápido ya pertenece a otro menú' AS 'mensaje';
        
        ELSE
			INSERT INTO combo ( combo, imagen, descripcion, idEstadoMenu, top, codigo ) 
				VALUES ( _combo, _imagen, _descripcion, _idEstadoMenu, 0, _codigo );

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
        END IF;

	ELSEIF _action = 'update' THEN
		IF ! codigoDuplicado( _codigo, NULL, _idCombo, NULL ) THEN
			SELECT 'danger' AS 'respuesta', 'Código rápido ya pertenece a otro menú' AS 'mensaje';
        
        ELSE
			UPDATE combo SET
				combo        = _combo,
				descripcion  = _descripcion,
				idEstadoMenu = _idEstadoMenu,
				codigo 		 = _codigo
			WHERE idCombo = _idCombo;

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
        END IF;
	
    ELSEIF _action = 'image' THEN
		UPDATE combo SET imagen = _imagen WHERE idCombo = _idCombo;

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
    
	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaMenuPrecio
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaMenuPrecio( _action VARCHAR(20), _idMenu INT, _idTipoServicio INT, _precio DOUBLE(10,2) )
BEGIN
	DECLARE CONTINUE HANDLER FOR 1062 BEGIN END;

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';


	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO menuPrecio ( idMenu, idTipoServicio, precio ) 
			VALUES ( _idMenu, _idTipoServicio, _precio ) 
            ON DUPLICATE KEY UPDATE precio =  _precio;

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'delete' THEN
		DELETE FROM menuPrecio
			WHERE idMenu = _idMenu AND idTipoServicio = _idTipoServicio;
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaComboPrecio
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaComboPrecio( _action VARCHAR(20), _idCombo INT, _idTipoServicio INT, _precio DOUBLE(10,2) )
BEGIN
	DECLARE CONTINUE HANDLER FOR 1062 BEGIN END;

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO comboPrecio ( idCombo, idTipoServicio, precio ) 
			VALUES ( _idCombo, _idTipoServicio, _precio )
            ON DUPLICATE KEY UPDATE precio =  _precio;

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'delete' THEN
		DELETE FROM comboPrecio
			WHERE idCombo = _idCombo AND idTipoServicio = _idTipoServicio;
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaComboDetalle
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaComboDetalle( _action VARCHAR(20), _idCombo INT, _idMenu INT, _cantidad DOUBLE(10,2) )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
		SELECT 'danger' AS 'respuesta', 'Menu ya registrado para este combo' AS 'mensaje';

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO comboDetalle ( idCombo, idMenu, cantidad ) 
			VALUES ( _idCombo, _idMenu, _cantidad );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'update' THEN
		UPDATE comboDetalle SET cantidad = _cantidad
			WHERE idCombo = _idCombo AND idMenu = _idMenu;
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'delete' THEN
		DELETE FROM comboDetalle WHERE idCombo = _idCombo AND idMenu = _idMenu;
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaSuperCombo
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaSuperCombo( _action VARCHAR(20), _idSuperCombo INT, _superCombo VARCHAR(45), _imagen VARCHAR(125), _descripcion TEXT, _idEstadoMenu INT, codigo INT )
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';


	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		IF ! codigoDuplicado( _codigo, NULL, NULL, NULL ) THEN
			SELECT 'danger' AS 'respuesta', 'Código rápido ya pertenece a otro menú' AS 'mensaje';
        
        ELSE
			INSERT INTO superCombo ( superCombo, imagen, descripcion, idEstadoMenu, top, codigo ) 
				VALUES ( _superCombo, _imagen, _descripcion, _idEstadoMenu, 0, _codigo );

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
        END IF;

	ELSEIF _action = 'update' THEN
		IF ! codigoDuplicado( _codigo, NULL, NULL, _idSuperCombo ) THEN
			SELECT 'danger' AS 'respuesta', 'Código rápido ya pertenece a otro menú' AS 'mensaje';
        
        ELSE
			UPDATE superCombo SET
				superCombo   = _superCombo,
				descripcion  = _descripcion,
				idEstadoMenu = _idEstadoMenu,
				codigo 		 = _codigo
			WHERE idSuperCombo = _idSuperCombo;

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
        END IF;
	
    ELSEIF _action = 'image' THEN
		UPDATE superCombo SET imagen = _imagen WHERE idSuperCombo = _idSuperCombo;

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaSuperComboPrecio
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaSuperComboPrecio( _action VARCHAR(20), _idSuperCombo INT, _idTipoServicio INT, _precio DOUBLE(10,2) )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
		SELECT 'danger' AS 'respuesta', 'Precio para Tipo de Servicio ya registrado' AS 'mensaje';

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO superComboPrecio ( idSuperCombo, idTipoServicio, precio ) 
			VALUES ( _idSuperCombo, _idTipoServicio, _precio );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'update' THEN
		UPDATE superComboPrecio SET precio = _precio
			WHERE idSuperCombo = _idSuperCombo AND idTipoServicio = _idTipoServicio;
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'delete' THEN
		DELETE FROM superComboPrecio 
			WHERE idSuperCombo = _idSuperCombo AND idTipoServicio = _idTipoServicio;
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaSuperComboDetalle
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaSuperComboDetalle( _action VARCHAR(20), _idSuperCombo INT, _idCombo INT, _cantidad DOUBLE(10,2) )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
		SELECT 'danger' AS 'respuesta', 'Combo ya registrado para este Super Combo' AS 'mensaje';

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO superComboDetalle ( idSuperCombo, idCombo, cantidad ) 
			VALUES ( _idSuperCombo, _idCombo, _cantidad );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'update' THEN
		UPDATE superComboDetalle SET cantidad = _cantidad
			WHERE idSuperCombo = _idSuperCombo AND idCombo = _idCombo;
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'delete' THEN
		DELETE FROM superComboDetalle WHERE idSuperCombo = _idSuperCombo AND idCombo = _idCombo;
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaOrdenCliente
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaOrdenCliente( _action VARCHAR(20), _idOrdenCliente INT, _numeroTicket INT, _usuarioResponsable VARCHAR(15), _idEstadoOrden INT, _comentario TEXT )
BEGIN
	DECLARE _tktPendiente BOOLEAN DEFAULT FALSE;
	DECLARE _estadoActualOrden INT DEFAULT 0;
    DECLARE _ordenesPreparacion INT DEFAULT 0;
    DECLARE _gruposCocina INT DEFAULT 1;
    DECLARE _numeroGrupo INT DEFAULT 0;
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';


	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		
		IF !ISNULL( _numeroTicket ) THEN
			SELECT TRUE INTO _tktPendiente FROM ordenCliente 
				WHERE numeroTicket = _numeroTicket AND ( idEstadoOrden BETWEEN 1 AND 4 )
			LIMIT 1;
		END IF;
        
        IF _tktPendiente THEN
			SELECT 'danger' AS 'respuesta', 'Error, EXISTE una orden pendiente con este # de Ticket' AS 'mensaje';
        
        ELSE
			SELECT valor INTO _gruposCocina
            FROM parametro WHERE idParametro = 'gruposCocina' LIMIT 1;
            
            SELECT numeroGrupo INTO _numeroGrupo
				FROM ordenCliente WHERE numMenu > 0
            ORDER BY idOrdenCliente DESC LIMIT 1;
            
            # SU ES MENOR AL LIMITE DE GRUPOS SUMA 1
            IF _numeroGrupo < _gruposCocina THEN
				SET _numeroGrupo = ( _numeroGrupo + 1 );
            
            # SI LLEGO AL TOTAL REGRESA AL INICIO
			ELSE
				SET _numeroGrupo = 1;
                
            END IF;
        
			INSERT INTO ordenCliente ( numeroTicket, usuarioPropietario, usuarioResponsable, idEstadoOrden, fechaRegistro, numMenu, numeroGrupo ) 
				VALUES ( _numeroTicket, @usuario, IFNULL( _usuarioResponsable, @usuario ), 1, NOW(), 0, _numeroGrupo );

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID()AS 'id';
        END IF;

	ELSEIF _action = 'update' THEN
		SELECT idEstadoOrden INTO _estadoActualOrden FROM ordenCliente 
			WHERE idOrdenCliente = _idOrdenCliente;

		IF _estadoActualOrden = 1 OR _estadoActualOrden = 2 THEN
			UPDATE ordenCliente SET 
				numeroTicket       = _numeroTicket,
				usuarioResponsable = _usuarioResponsable
			WHERE idOrdenCliente = _idOrdenCliente;
			SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';

		ELSE

			SELECT 'danger' AS 'respuesta', 'Estado actual no permite modificación' AS 'mensaje';
		END IF;

	ELSEIF _action = 'cancel' THEN

		SET @comentario = _comentario;
		
        SELECT COUNT(*) INTO _ordenesPreparacion FROM detalleOrdenMenu 
			WHERE idOrdenCliente = _idOrdenCliente AND idEstadoDetalleOrden > 1 AND idEstadoDetalleOrden != 10;
		
        IF _ordenesPreparacion > 0 THEN
			SELECT 'danger' AS 'respuesta', 'Error, existen menús en preparación' AS 'mensaje';
        
        ELSE
			# CANCELAR ORDENES
			UPDATE detalleOrdenMenu SET idEstadoDetalleOrden = 10 WHERE idOrdenCliente = _idOrdenCliente;
            UPDATE detalleOrdenCombo SET idEstadoDetalleOrden = 10 WHERE idOrdenCliente = _idOrdenCliente;
            
            # CANCELA ORDEN PRINCIPAL
            UPDATE ordenCliente SET idEstadoOrden = 10 WHERE idOrdenCliente = _idOrdenCliente;
            
			SELECT 'success' AS 'respuesta', 'Cancelado correctamente' AS 'mensaje';
        END IF;
	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultCliente
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultCliente( _action VARCHAR(15), _nit VARCHAR(15), _nombre VARCHAR(65), _cui VARCHAR(13), 
	_correo VARCHAR(65), _telefono VARCHAR(8),  _direccion VARCHAR(95), _idTipoCliente INT )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
        SELECT 'danger' AS 'respuesta', 'Error, NIT duplicado' AS 'mensaje';
    
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
    
    IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO cliente ( nit, nombre, cui, correo, telefono, direccion, idTipoCliente, fechaRegistro, usuario ) 
			VALUES ( _nit, _nombre, _cui, _correo, _telefono, _direccion, _idTipoCliente, now(), @usuario );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', last_insert_id() AS 'id';
    ELSEIF _action = 'update' THEN
		UPDATE cliente SET
			nit 		= _nit, 
			nombre 		= _nombre, 
			cui 		= _cui, 
			correo 		= _correo, 
			telefono 	= _telefono,
			direccion 	= _direccion,
			idTipoCliente = _idTipoCliente
		WHERE idCliente = _idCliente;
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaDetalleOrdenMenu
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaDetalleOrdenMenu( _action VARCHAR(20), _idDetalleOrdenMenu INT, _idOrdenCliente INT, _idMenu INT, _cantidad DOUBLE(10,2), _idEstadoDetalleOrden INT, _idTipoServicio INT, _idFactura INT, _usuarioResponsable VARCHAR(15), _observacion TEXT, _comentario TEXT )
BEGIN
	DECLARE _estadoActualDetalle INT;
	DECLARE _estadoActualOrden INT;
    DECLARE _idMenuActual INT;
	DECLARE _perteneceCombo BOOLEAN;
	DECLARE _ids TEXT DEFAULT '';
	DECLARE _yaFacturado BOOLEAN DEFAULT FALSE;
    DECLARE _seCocina BOOLEAN DEFAULT TRUE;

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	# ESTADO DETALLE ORDEN MENU 
	IF !ISNULL( _idDetalleOrdenMenu ) THEN
		SELECT dom.idEstadoDetalleOrden, dom.perteneceCombo, dom.idMenu, IFNULL( _idOrdenCliente, dom.idOrdenCliente ), 
			IFNULL( _idTipoServicio, dom.idTipoServicio), IF( !ISNULL( dof.idFactura ), TRUE, FALSE )
		INTO
			_estadoActualDetalle, _perteneceCombo, _idMenuActual, _idOrdenCliente, 
            _idTipoServicio, _yaFacturado
		FROM detalleOrdenMenu AS dom
			JOIN menu AS m 
				ON dom.idMenu = m.idMenu
                
			LEFT JOIN detalleOrdenFactura AS dof
				ON dom.idDetalleOrdenMenu = dof.idDetalleOrdenMenu
                
		WHERE dom.idDetalleOrdenMenu = _idDetalleOrdenMenu
		LIMIT 1;
	END IF;

	# ESTADO ORDEN CLIENTE 
	SELECT idEstadoOrden INTO _estadoActualOrden FROM ordenCliente WHERE idOrdenCliente = _idOrdenCliente;

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		# SUMA CANTIDAD DE MENUS ORDENADOS POR CLIENTE
        UPDATE ordenCliente SET numMenu = numMenu + _cantidad WHERE idOrdenCliente = _idOrdenCliente;
        
        SELECT seCocina INTO _seCocina FROM menu WHERE idMenu = _idMenu;
		
        WHILE _cantidad > 0 DO
			INSERT INTO detalleOrdenMenu 
				(idOrdenCliente, idMenu, cantidad, idEstadoDetalleOrden, idTipoServicio, usuario, usuarioResponsable, perteneceCombo, observacion )
			VALUES (_idOrdenCliente, _idMenu, 1, IF( _seCocina, 1, 3 ), _idTipoServicio, @usuario, IFNULL( _usuarioResponsable, @usuario ), 0, _observacion );

			SET _ids = CONCAT( _ids, '_', LAST_INSERT_ID() );
			
			UPDATE menu SET top = top + 1 WHERE idMenu = _idMenu;
            
            SET _cantidad = _cantidad - 1;
        END WHILE;

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', _ids AS 'ids';

	ELSEIF _action = 'cancel' THEN
		SET @comentario = _comentario;
        
        # SI ES DIFERENTE A PENDIENTE
		IF _estadoActualDetalle != 1 THEN
			SELECT 'warning' AS 'respuesta', 'Estado actual no permite cancelar' AS 'mensaje';
            
		ELSE
			UPDATE detalleOrdenMenu SET idEstadoDetalleOrden = 10
				WHERE idDetalleOrdenMenu = _idDetalleOrdenMenu;
			
            # DESCUENTA DE NUMERO MENUS DE TICKET
            IF ! _perteneceCombo THEN
				UPDATE ordenCliente SET numMenu = numMenu - 1 WHERE idOrdenCliente = _idOrdenCliente;
            END IF;

			SELECT 'success' AS 'respuesta', 'Cancelado correctamente' AS 'mensaje';
		END IF;
        
    ELSEIF _action = 'estado' THEN
		SET @comentario = _comentario;
        
        # SI ES PARA RESTAURANTE DEBE DE ESTAR := SERVIDO
        IF ( _idTipoServicio = 2 AND _idEstadoDetalleOrden = 6 AND _estadoActualDetalle != 4 ) THEN
			
            SELECT 'danger' AS 'respuesta', 'Estado actual no permite Facturar' AS 'mensaje';
        
		ELSEIF ( ( _idEstadoDetalleOrden > _estadoActualDetalle ) OR @isAdmin ) THEN
			
			# CAMBIA ESTADO A DETALLE DE ORDEN
			UPDATE detalleOrdenMenu    SET   idEstadoDetalleOrden = _idEstadoDetalleOrden
			WHERE idDetalleOrdenMenu = _idDetalleOrdenMenu;
			
            # SI PERTENECE A COMOB
            IF _perteneceCombo THEN
            	SET @detalleComboPendiente = NULL;

				# NUMERO DE ORDENES CON ESTADO ANTERIOR
				SELECT SUM( IF( dom.idEstadoDetalleOrden < _idEstadoDetalleOrden, 1, 0 ) ), dcmo.idDetalleOrdenCombo
					INTO @detalleComboPendiente, @idDetalleOrdenCombo
				FROM detalleComboMenu AS dcm
					JOIN detalleComboMenu AS dcmo
						ON dcmo.idDetalleOrdenCombo = dcm.idDetalleOrdenCombo
					LEFT JOIN detalleOrdenMenu AS dom
						ON dom.idDetalleOrdenMenu = dcmo.idDetalleOrdenMenu
							AND dcm.idDetalleOrdenMenu != dom.idDetalleOrdenMenu
				WHERE dcm.idDetalleOrdenMenu = _idDetalleOrdenMenu;
                
                # SI DETALLE ES IGUAL A CERO CAMBIA DE ESTADO COMBO
                IF @detalleComboPendiente = 0 THEN
					UPDATE detalleOrdenCombo SET idEstadoDetalleOrden = _idEstadoDetalleOrden 
						WHERE idDetalleOrdenCombo = @idDetalleOrdenCombo;

					# VERIFICA SI YA ESTA FACTURADO
					SELECT TRUE INTO _yaFacturado FROM detalleOrdenFactura WHERE idDetalleOrdenCombo = @idDetalleOrdenCombo;

					# SI TODOS LOS MENUS DEL COMBO ESTAN SERVIDOS Y ESTA FACTURADO, CAMBIA ESTADO DE COMBO A FACTURADO
					IF _idEstadoDetalleOrden = 4 AND _yaFacturado THEN
						UPDATE detalleOrdenCombo SET idEstadoDetalleOrden = 6 
							WHERE idDetalleOrdenCombo = @idDetalleOrdenCombo;

					END IF;

                END IF;
            END IF;
            
            # SI YA ESTA FACTURADO
            IF _idEstadoDetalleOrden = 4 AND _yaFacturado AND ! _perteneceCombo THEN
				UPDATE detalleOrdenMenu    SET   idEstadoDetalleOrden = 6
				WHERE idDetalleOrdenMenu = _idDetalleOrdenMenu;
                
            END IF;
			
            # ACTUALIZA ESTADO ORDEN
            CALL cambioEstadoOrdenCliente( _idOrdenCliente, _idEstadoDetalleOrden );
            
            # DESCUENTA DE NUMERO MENUS DE TICKET
			/*IF ! _perteneceCombo AND _idEstadoDetalleOrden = 10 THEN
				UPDATE ordenCliente SET numMenu = numMenu - 1 WHERE idOrdenCliente = _idOrdenCliente;
			END IF;*/

			SELECT 'success' AS 'respuesta', 'Cambio de estado guardado correctamente' AS 'mensaje';
		
        ELSE
			SELECT 'danger' AS 'respuesta', 'No se puede retornar a un estado anterior' AS 'mensaje';
		END IF;

	ELSEIF _action = 'responsable' THEN
		# SI EL MENU PERTENECE A UN COMBO
		IF _perteneceCombo THEN
			SELECT 'danger' AS 'respuesta', 'No es posible, menú pertenece a un combo' AS 'mensaje';

		ELSE
			UPDATE detalleOrdenMenu SET
				usuarioResponsable = _usuarioResponsable
			WHERE idDetalleOrdenMenu = _idDetalleOrdenMenu;

			SELECT 'success' AS 'respuesta', 'Cambio de responsable exitoso' AS 'mensaje';
		END IF;

	ELSEIF _action = 'tipoServicio' THEN

		# SI EL MENU PERTENECE A UN COMBO
		IF _perteneceCombo THEN
			SELECT 'danger' AS 'respuesta', 'No es posible, menú pertenece a un combo' AS 'mensaje';

		ELSEIF ( ( _estadoActualDetalle != 6 AND _estadoActualDetalle != 10 ) OR @isAdmin ) THEN
			UPDATE detalleOrdenMenu SET
				idTipoServicio = _idTipoServicio
			WHERE idDetalleOrdenMenu = _idDetalleOrdenMenu;

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
		ELSE
			SELECT 'danger' AS 'respuesta', 'El estado actual no permite modificación' AS 'mensaje';
		END IF;

	ELSEIF _action = 'menu' THEN

		# SI EL MENU PERTENECE A UN COMBO
		IF _perteneceCombo THEN
			SELECT 'danger' AS 'respuesta', 'No es posible, menú pertenece a un combo' AS 'mensaje';

		ELSEIF ( _estadoActualDetalle = 1 OR @isAdmin ) THEN
			UPDATE detalleOrdenMenu SET 
				idMenu = _idMenu
			WHERE idDetalleOrdenMenu = _idDetalleOrdenMenu;

			SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
		ELSE
			SELECT 'danger' AS 'respuesta', 'El estado actual no permite modificación' AS 'mensaje';
		END IF;

	ELSEIF _action = 'asignarOtroCliente' THEN

		# SI EL MENU PERTENECE A UN COMBO
		IF _perteneceCombo THEN
			SELECT 'danger' AS 'respuesta', 'No es posible, menú pertenece a un combo' AS 'mensaje';

		ELSEIF ISNULL( _estadoActualDetalle ) THEN
			SELECT 'danger' AS 'respuesta', 'Existe información faltante' AS 'mensaje';

		# SI EL DETALLE ESTA EN ESTADO: Realizado (6), Cancelado (10)
		ELSEIF ( _estadoActualDetalle = 6 OR _estadoActualDetalle = 10 ) THEN
			SELECT 'danger' AS 'respuesta', 'No es posible realizar la asignación, por estado actual de pedido' AS 'mensaje';
			
		ELSE
			UPDATE detalleOrdenMenu SET 
				idOrdenCliente = _idOrdenCliente
			WHERE idDetalleOrdenMenu = _idDetalleOrdenMenu;

			SELECT 'success' AS 'respuesta', 'Realizado correctamente' AS 'mensaje';
		END IF;
	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure _comboDetalleMenu
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE _comboDetalleMenu( _idDetalleOrdenCombo INT, _idCombo INT, _idTipoServicio INT, _idEstadoDetalleOrden INT, _usuarioResponsable VARCHAR( 15 ), _idOrdenCliente INT, _observacion TEXT )
BEGIN
	DECLARE finCursor BOOLEAN DEFAULT FALSE;
	DECLARE _idMenu INT;
    DECLARE _cantidad INT;
    DECLARE _seCocina BOOLEAN;

    # DECLARACION DE CURSOR PARA OBTENER DETALLE DE COMBO
    DEClARE cursorMenu CURSOR FOR 
		SELECT cd.idMenu, cd.cantidad, m.seCocina
        FROM comboDetalle AS cd
			JOIN menu AS m
				ON cd.idMenu = m.idMenu
                
        WHERE cd.idCombo = _idCombo;

	# SI YA NO HAY MAS DETALLE DE COMBO
    DECLARE CONTINUE HANDLER FOR NOT FOUND 
		SET finCursor = TRUE;

	OPEN cursorMenu;

	loopMenu: LOOP

		FETCH cursorMenu INTO _idMenu, _cantidad, _seCocina;
        
		IF finCursor THEN 
			LEAVE loopMenu;
		END IF;
        
        # MIENTRAS EXISTA CANTIDAD, SE AGREGA UNO A UNO
        WHILE _cantidad >= 1 DO
			INSERT INTO detalleOrdenMenu
				( idOrdenCliente, idMenu, cantidad, idEstadoDetalleOrden, idTipoServicio, usuario, usuarioResponsable, perteneceCombo, observacion )
			VALUES ( _idOrdenCliente, _idMenu, 1, IF( _seCocina, _idEstadoDetalleOrden, 3 ), _idTipoServicio, @usuario, _usuarioResponsable, 1, _observacion );
            
            SET @idDetalleOrdenMenu = LAST_INSERT_ID();
            
            INSERT INTO detalleComboMenu( idDetalleOrdenMenu, idDetalleOrdenCombo ) 
				VALUES ( @idDetalleOrdenMenu, _idDetalleOrdenCombo );
			
            SET _cantidad = _cantidad - 1;
        END WHILE;

	END LOOP loopMenu;

	CLOSE cursorMenu;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaDetalleOrdenCombo
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaDetalleOrdenCombo( _action VARCHAR(20), _idDetalleOrdenCombo INT, _idOrdenCliente INT, _idCombo INT, _cantidad DOUBLE(10,2), _idEstadoDetalleOrden INT, _idTipoServicio INT, _idFactura INT, _usuarioResponsable VARCHAR(15), _observacion TEXT, _comentario TEXT )
BEGIN
	DECLARE _estadoActualDetalle INT;
	DECLARE _estadoActualOrden INT;
    DECLARE _ids TEXT DEFAULT '';
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	# ESTADO DETALLE ORDEN MENU 
	SELECT idEstadoDetalleOrden, IFNULL( _idOrdenCliente, idOrdenCliente ), IFNULL( _idTipoServicio, idTipoServicio )
		INTO _estadoActualDetalle, _idOrdenCliente, _idTipoServicio
	FROM detalleOrdenCombo WHERE idDetalleOrdenCombo = _idDetalleOrdenCombo;

	# ESTADO ORDEN CLIENTE 
	SELECT idEstadoOrden INTO _estadoActualOrden FROM ordenCliente WHERE idOrdenCliente = _idOrdenCliente;

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		# SUMA CANTIDAD DE MENUS ORDENADOS POR CLIENTE
        UPDATE ordenCliente SET numMenu = numMenu + _cantidad WHERE idOrdenCliente = _idOrdenCliente;
            
		WHILE _cantidad > 0 DO

			INSERT INTO detalleOrdenCombo (idOrdenCliente, idCombo, cantidad, idEstadoDetalleOrden, idTipoServicio, usuario, usuarioResponsable, observacion )
			VALUES (_idOrdenCliente, _idCombo, 1, 1, _idTipoServicio, @usuario, IFNULL( _usuarioResponsable, @usuario ), _observacion );

			UPDATE combo SET top = top + 1 WHERE idCombo = _idCombo;

			SET @idDetalleOrdenCombo = LAST_INSERT_ID();
            
            SET _ids = CONCAT( _ids, '_', @idDetalleOrdenCombo );

			# INGRESA DETALLE DE MENU DE COMBO
			CALL _comboDetalleMenu( @idDetalleOrdenCombo, _idCombo, _idTipoServicio, 1, IFNULL( _usuarioResponsable, @usuario ), _idOrdenCliente, _observacion );

			SET _cantidad = _cantidad - 1;
		END WHILE;

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', _ids AS 'ids';
        
	ELSEIF _action = 'cancel' THEN
		
        SET @comentario = _comentario;
    
        # SI ES DIFERENTE A PENDIENTE
		IF _estadoActualDetalle != 1 THEN
			SELECT 'warning' AS 'respuesta', 'Estado actual no permite cancelar' AS 'mensaje';
            
		ELSE
			UPDATE detalleOrdenCombo SET idEstadoDetalleOrden = 10
				WHERE idDetalleOrdenCombo = _idDetalleOrdenCombo;
			
            # DESCUENTA DE NUMERO MENUS ORDEN
            UPDATE ordenCliente SET numMenu = numMenu - 1 WHERE idOrdenCliente = _idOrdenCliente;
            
			# ACTUALIZA LOS ESTADOS DETALLE DE COMBO
			UPDATE detalleOrdenMenu AS dom
				JOIN detalleComboMenu AS dcm
					ON dom.idDetalleOrdenMenu = dcm.idDetalleOrdenMenu
						AND dcm.idDetalleOrdenCombo = _idDetalleOrdenCombo
			SET dom.idEstadoDetalleOrden = 10;

			SELECT 'success' AS 'respuesta', 'Cancelado correctamente' AS 'mensaje';
		END IF;

	ELSEIF _action = 'estado' THEN
		
        SET @comentario = _comentario;
        
        # SI ES PARA RESTAURANTE DEBE DE ESTAR := SERVIDO
        IF ( _idTipoServicio = 2 AND _idEstadoDetalleOrden = 6 AND _estadoActualDetalle != 4 ) THEN
			
            SELECT 'danger' AS 'respuesta', 'Estado actual no permite Facturar' AS 'mensaje';
        
		ELSEIF ( ( _idEstadoDetalleOrden > _estadoActualDetalle ) OR @isAdmin ) THEN
			UPDATE detalleOrdenCombo SET
				idEstadoDetalleOrden = _idEstadoDetalleOrden
			WHERE idDetalleOrdenCombo = _idDetalleOrdenCombo;
            
            # DESCUENTA DE NUMERO MENUS ORDEN SI ES CANCELAR
            /*IF _idEstadoDetalleOrden = 10 THEN
				UPDATE ordenCliente SET numMenu = numMenu - 1 WHERE idOrdenCliente = _idOrdenCliente;
            END IF;*/

			# ACTUALIZA LOS ESTADOS DETALLE DE COMBO
			UPDATE detalleOrdenMenu AS dom
				JOIN detalleComboMenu AS dcm
					ON dom.idDetalleOrdenMenu = dcm.idDetalleOrdenMenu
						AND dcm.idDetalleOrdenCombo = _idDetalleOrdenCombo
			SET dom.idEstadoDetalleOrden = _idEstadoDetalleOrden;
            
            # ACTUALIZA ESTADO ORDEN
            CALL cambioEstadoOrdenCliente( _idOrdenCliente, _idEstadoDetalleOrden );

			SELECT 'success' AS 'respuesta', 'Cambio de estado realizado correctamente' AS 'mensaje';
            
		ELSE
			SELECT 'danger' AS 'respuesta', 'No se puede retornar a un estado anterior' AS 'mensaje';
            
		END IF;

	ELSEIF _action = 'responsable' THEN
		UPDATE detalleOrdenCombo SET
			usuarioResponsable = _usuarioResponsable
		WHERE idDetalleOrdenCombo = _idDetalleOrdenCombo;

		# ACTUALIZA RESPONSABLE DETALLE DE COMBO
		UPDATE detalleOrdenMenu AS dom
			JOIN detalleComboMenu AS dcm
				ON dom.idDetalleOrdenMenu = dcm.idDetalleOrdenMenu
					AND dcm.idDetalleOrdenCombo = _idDetalleOrdenCombo
		SET dom.usuarioResponsable = _usuarioResponsable;

		SELECT 'success' AS 'respuesta', 'Cambio de responsable exitoso' AS 'mensaje';

	ELSEIF _action = 'tipoServicio' THEN
		IF ( ( _estadoActualDetalle != 6 AND _estadoActualDetalle != 10 ) OR @isAdmin ) THEN
			UPDATE detalleOrdenCombo SET
				idTipoServicio = _idTipoServicio
			WHERE idDetalleOrdenCombo = _idDetalleOrdenCombo;

			# ACTUALIZA TIPO SERVICIO DETALLE DE COMBO
			UPDATE detalleOrdenMenu AS dom
				JOIN detalleComboMenu AS dcm
					ON dom.idDetalleOrdenMenu = dcm.idDetalleOrdenMenu
						AND dcm.idDetalleOrdenCombo = _idDetalleOrdenCombo
			SET dom.idTipoServicio = _idTipoServicio;

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
		ELSE
			SELECT 'danger' AS 'respuesta', 'El estado actual no permite modificación' AS 'mensaje';
		END IF;

	ELSEIF _action = 'asignarOtroCliente' THEN

		IF ISNULL( _estadoActualDetalle ) THEN
			SELECT 'danger' AS 'respuesta', 'Existe información faltante' AS 'mensaje';

		# SI EL DETALLE ESTA EN ESTADO: Realizado (6), Cancelado (10)
		ELSEIF ( _estadoActualDetalle = 6 OR _estadoActualDetalle = 10 ) THEN
			SELECT 'danger' AS 'respuesta', 'No es posible realizar la asignación, por estado actual de pedido' AS 'mensaje';
			
		ELSE
			UPDATE detalleOrdenCombo SET 
				idOrdenCliente = _idOrdenCliente
			WHERE idDetalleOrdenCombo = _idDetalleOrdenCombo;

			# ACTUALIZA ORDEN CLIENTE DETALLE DE COMBO
			UPDATE detalleOrdenMenu AS dom
				JOIN detalleComboMenu AS dcm
					ON dom.idDetalleOrdenMenu = dcm.idDetalleOrdenMenu
						AND dcm.idDetalleOrdenCombo = _idDetalleOrdenCombo
			SET dom.idOrdenCliente = _idOrdenCliente;

			SELECT 'success' AS 'respuesta', 'Realizado correctamente' AS 'mensaje';
		END IF;
	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaCierreDiario
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaCierreDiario( _action VARCHAR(20), _idCierreDiario INT, _fechaCierre DATE, _comentario TEXT, _todos BOOLEAN )
BEGIN
	DECLARE CONTINUE HANDLER FOR 1062
		SELECT 'info' AS 'respuesta', 'Error, ya se ha realizado el cierre de este día' AS 'mensaje';
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO cierreDiario ( fechaCierre, comentario, usuario, fechaRegistro, todos )
			VALUES ( _fechaCierre, _comentario, @usuario, NOW(), _todos );
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';

	ELSEIF _action = 'update' THEN
		UPDATE cierreDiario SET 
			fechaCierre = _fechaCierre,
			comentario  = _comentario
		WHERE idCierreDiario = _idCierreDiario;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaCierreDiarioProducto
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaCierreDiarioProducto( _action VARCHAR(20), _idCierreDiario INT, _idProducto INT, 
	_cantidadCocina DOUBLE(10,2), _cantidadBodega DOUBLE(10,2), _cantidadMostrador DOUBLE(10,2), 
    _actualizarDisponibilidad BOOLEAN )
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO cierreDiarioProducto ( idCierreDiario, idProducto, cantidadCocina, cantidadBodega, cantidadMostrador ) 
			VALUES ( _idCierreDiario, _idProducto, _cantidadCocina, _cantidadBodega, _cantidadMostrador );

		# SI ACTUALIZA DISPONIBILIDAD DE PRODUCTO
		IF _actualizarDisponibilidad THEN
			UPDATE producto SET disponibilidad = ( _cantidadCocina + _cantidadBodega + _cantidadMostrador )
				WHERE idProducto = _idProducto;
		END IF;
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaFactura
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaFactura( _action VARCHAR(20), _idFacturaCompra INT, _idEstadoFactura INT, _noFactura VARCHAR(15), _proveedor VARCHAR(45), _fechaFactura DATE, _comentario TEXT )
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO facturaCompra( idEstadoFactura, noFactura, proveedor, fechaFactura, comentario )
			VALUES ( _idEstadoFactura, _noFactura, _proveedor, _fechaFactura, _comentario );
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';

	ELSEIF _action = 'update' THEN
		UPDATE facturaCompra SET
			idEstadoFactura = _idEstadoFactura,
			noFactura       = _noFactura,
			proveedor       = _proveedor,
			fechaFactura    = _fechaFactura,
			comentario      = _comentario
		WHERE idFacturaCompra = _idFacturaCompra;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- function codigoDuplicado
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE FUNCTION codigoDuplicado( _codigo INT, _idMenu INT, _idCombo INT, _idSuperCombo INT )
RETURNS BOOLEAN
BEGIN
	DECLARE _response BOOLEAN DEFAULT TRUE;
	
    IF !ISNULL( _codigo ) AND _codigo > 0 THEN
		SELECT FALSE INTO _response FROM menu WHERE codigo = _codigo AND idMenu != IFNULL( _idMenu, 0 ) AND idEstadoMenu = 1 LIMIT 1;
        SELECT FALSE INTO _response FROM combo WHERE codigo = _codigo AND idCombo != IFNULL( _idCombo, 0 ) AND idEstadoMenu = 1 LIMIT 1;
        SELECT FALSE INTO _response FROM superCombo WHERE codigo = _codigo AND idSuperCombo != IFNULL( _idSuperCombo, 0 ) AND idEstadoMenu = 1 LIMIT 1;
    END IF;
    
    RETURN _response;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaEvento
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaEvento( _action VARCHAR(15), _idEvento INT, _evento VARCHAR(75), _idCliente INT, _fechaEvento DATE, _idSalon INT, _idEstadoEvento INT, _numeroPersonas INT, _horaInicio TIME, _horaFinal TIME, _observacion TEXT, _comentario TEXT )
COMMENT 'INSERTA / ACTUALIZA EVENTO'
BEGIN

	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
    SET @comentario = _comentario;
    
    IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';
        
	ELSEIF _fechaEvento < CURDATE() THEN
		SELECT 'danger' AS 'respuesta', 'Fecha de evento NO puede ser menor al actual' AS 'mensaje';
	
	ELSEIF _action = 'insert' THEN
		INSERT INTO evento ( evento, idCliente, fechaEvento, idSalon, idEstadoEvento, numeroPersonas, horaInicio, horaFinal, observacion, usuario, fechaRegistro ) 
			VALUES ( _evento, _idCliente, _fechaEvento, _idSalon, _idEstadoEvento, _numeroPersonas, _horaInicio, _horaFinal, _observacion, @usuario, now() );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
        
    ELSEIF _action = 'update' THEN
		IF _idEstadoEvento = 5 AND _fechaEvento != curdate() THEN
			SELECT 'warning' AS 'respuesta', CONCAT( 'No se puede finalizar evento, corresponde a otra fecha: ', DATE_FORMAT( _fechaEvento, '%d/%m/%Y' ) )AS 'mensaje';
        
        ELSE
			UPDATE evento SET
				evento         = _evento,
				idCliente      = _idCliente,
				fechaEvento    = _fechaEvento,
				idSalon        = _idSalon,
				idEstadoEvento = _idEstadoEvento, 
				numeroPersonas = _numeroPersonas,
				horaInicio     = _horaInicio,
				horaFinal      = _horaFinal,
				observacion    = _observacion
			WHERE idEvento = _idEvento;
			
			SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
        END IF;
        
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaOrdenEvento
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaOrdenEvento( _action VARCHAR(15), _idEvento INT, _idOrdenCliente INT )
COMMENT 'INSERTAR / ELIMINAR ORDEN CLIENTE A EVENTO'
BEGIN
	DECLARE EXIT HANDLER FOR 1062
        SELECT 'danger' AS 'respuesta', 'Error, orden ya pertence a este evento' AS 'mensaje';
    
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
    
    IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO eventoOrdenCliente ( idEvento, idOrdenCliente, usuario, fechaRegistro ) 
			VALUES ( _idEvento, _idOrdenCliente, @usuario, NOW() );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
        
    ELSEIF _action = 'delete' THEN
		DELETE FROM eventoOrdenCliente WHERE idEvento = _idEvento AND idOrdenCliente = _idOrdenCliente;
		
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaReajuste
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaReajuste( _action VARCHAR(20), _observacion TEXT )
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO reajuste( observacion, usuario, fechaRegistro) 
			VALUES ( _observacion, @usuario, NOW() );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaReajusteProducto
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaReajusteProducto( _action VARCHAR(20), _idReajuste INT, _idProducto INT, _cantidad DOUBLE(10,2), _esIncremento BOOLEAN )
BEGIN
	DECLARE _disponibilidad DOUBLE(10,2);

	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		SELECT disponibilidad INTO _disponibilidad FROM producto WHERE idProducto = _idProducto;

		IF ! _esIncremento AND _disponibilidad < _cantidad THEN
			SELECT 'danger' AS 'respuesta', 'La disponibilidad no puede ser menor a cero' AS 'mensaje';

		ELSE
			INSERT INTO reajusteProducto( idReajuste, idProducto, cantidad, esIncremento ) 
				VALUES ( _idReajuste, _idProducto, _cantidad, _esIncremento );
			
			IF _esIncremento THEN
				UPDATE producto SET disponibilidad = disponibilidad + _cantidad
					WHERE idProducto = _idProducto;
			ELSE
				UPDATE producto SET disponibilidad = disponibilidad - _cantidad
					WHERE idProducto = _idProducto;
			END IF;

			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
		END IF;
	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure destinoMenuUsuario
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE destinoMenuUsuario( _action varchar(15), _usuario varchar(15), _idDestinoMenu INT )
BEGIN
	DECLARE EXIT HANDLER FOR 1062
        SELECT 'danger' AS 'respuesta', 'Ya tiene este destino asignado' AS 'mensaje';

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF sesionValida() THEN
        IF _action = 'insert' THEN
			INSERT INTO destinoMenuUsuario( usuario, idDestinoMenu )
			VALUES ( _usuario, _idDestinoMenu );
            
            SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
            
		ELSEIF _action = 'delete' THEN
			DELETE FROM destinoMenuUsuario WHERE usuario = _usuario AND idDestinoMenu = _idDestinoMenu;
				
            SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';
            
		ELSE
        
			SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
		END IF;
    
    ELSE
		SELECT 'danger' AS 'respuesta', 'Sesión no válida o acceso denegado' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaCaja
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaCaja( _action VARCHAR(15), _idCaja INT, _idEstadoCaja INT, _efectivoInicial DOUBLE(12,2), _efectivoFinal DOUBLE(12,2), _efectivoSobrante DOUBLE(10,2), _efectivoFaltante DOUBLE(10,2) )
BEGIN
	DECLARE _cajaAbierta BOOLEAN DEFAULT FALSE;

    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';
    
	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		# SI TIENE UNA APERTURA PENDIENTE
		SELECT TRUE INTO _cajaAbierta FROM caja WHERE usuario = @usuario AND idEstadoCaja = 1;
        
        IF _cajaAbierta THEN
			SELECT 'danger' AS 'respuesta', 'Ya tiene aperturada su caja' AS 'mensaje';
        
        ELSE
			INSERT INTO caja
				( usuario, idEstadoCaja, fechaApertura, efectivoInicial, efectivoFinal, efectivoSobrante, efectivoFaltante ) 
			VALUES
				( @usuario, 1, CURDATE(), _efectivoInicial, _efectivoFinal, _efectivoSobrante, _efectivoFaltante );
				
			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
        END IF;
	
    ELSEIF _action = 'cierre' THEN
		UPDATE caja SET
			idEstadoCaja 		= _idEstadoCaja,
            efectivoInicial 	= _efectivoInicial,
            efectivoFinal 		= _efectivoFinal,
            efectivoSobrante 	= _efectivoSobrante,
            efectivoFaltante 	= _efectivoFaltante
		WHERE idCaja = _idCaja;
    
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
    
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
end$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaReajusteCaja
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaReajusteCaja( _action VARCHAR(15), _idReajusteCaja INT, _idCaja INT, _monto DOUBLE(10,2), _observacion TEXT )
BEGIN
    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';
    
	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
    
		INSERT INTO reajusteCaja
			( idCaja, monto, observacion, usuario, fechaRegistro ) 
		VALUES
			( _idCaja, _monto, _observacion, @usuario, NOW() );
			
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
	
    ELSEIF _action = 'delete' THEN
    
		DELETE FROM reajusteCaja WHERE idReajusteCaja = _idReajusteCaja;
			
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';
    
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
end$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaFormaPago
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaFormaPago( _action VARCHAR(15), _idFactura INT, _idFormaPago INT, _monto DOUBLE(10,2) )
BEGIN
    DECLARE EXIT HANDLER FOR 1062
        SELECT 'danger' AS 'respuesta', 'Forma de pago duplicado' AS 'mensaje';
    
    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';
    
	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO facturaFormaPago
			( idFactura, idFormaPago, monto ) 
		VALUES
			( _idFactura, _idFormaPago, _monto );
			
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
	
    ELSEIF _action = 'delete' THEN
		DELETE FROM facturaFormaPago WHERE idFactura = _idFactura AND idFormaPago = _idFormaPago;
    
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaDetalleFactura
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaDetalleFactura( _action VARCHAR(15), _idFactura INT, _idDetalleOrdenMenu INT, _idDetalleOrdenCombo INT, _precioMenu DOUBLE(10,2), _descuento DOUBLE(10,2), _comentario TEXT )
BEGIN
	DECLARE _perteneceCombo BOOLEAN DEFAULT FALSE;
    DECLARE _estadoActualDetalle INT;
    DECLARE _idTipoServicio INT;
    DECLARE _idOrdenCliente INT;
    DECLARE _yaFacturado BOOLEAN DEFAULT FALSE;
    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

    DECLARE EXIT HANDLER FOR 1062
        SELECT 'danger' AS 'respuesta', 'Ya existe este detalle en la Factura' AS 'mensaje';
    
	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN

		# SI ES MENU
		IF !ISNULL( _idDetalleOrdenMenu ) THEN
			SET _idDetalleOrdenCombo = NULL;
            
			SELECT dom.perteneceCombo, dom.idEstadoDetalleOrden, dom.idTipoServicio, IF( !ISNULL( dof.idFactura ), TRUE, FALSE ), idOrdenCliente
				INTO _perteneceCombo, _estadoActualDetalle, _idTipoServicio, _yaFacturado, _idOrdenCliente
			FROM detalleOrdenMenu AS dom
				LEFT JOIN detalleOrdenFactura AS dof 
					ON dom.idDetalleOrdenMenu = dof.idDetalleOrdenMenu
            WHERE dom.idDetalleOrdenMenu = _idDetalleOrdenMenu LIMIT 1;
			
		# SI ES COMBO
		ELSE
			SET _idDetalleOrdenMenu = NULL;
            
            SELECT doc.idEstadoDetalleOrden, doc.idTipoServicio, IF( !ISNULL( dof.idFactura ), TRUE, FALSE ), idOrdenCliente
				INTO  _estadoActualDetalle, _idTipoServicio, _yaFacturado, _idOrdenCliente
			FROM detalleOrdenCombo AS doc
				LEFT JOIN detalleOrdenFactura AS dof 
					ON doc.idDetalleOrdenCombo = dof.idDetalleOrdenCombo
            WHERE doc.idDetalleOrdenCombo = _idDetalleOrdenCombo LIMIT 1;
		END IF;


		# SI ES PARA RESTAURANTE DEBE DE ESTAR := SERVIDO
        IF ( _idTipoServicio = 2 AND _estadoActualDetalle != 4 ) THEN
			
            SELECT 'danger' AS 'respuesta', 'Estado actual no permite Facturar' AS 'mensaje';
		
        # SI YA ESTA FACTURADO MUESTRA ERROR
        ELSEIF ( _yaFacturado ) THEN
			SELECT 'info' AS 'respuesta', 'Detalle de Orden ya facturado' AS 'mensaje';
            
		# SI PERTENECE A COMBO
		ELSEIF _perteneceCombo THEN
			SELECT 'danger' AS 'respuesta', 'Error, detalle pertenece a combo' AS 'mensaje';

		# SI NO EXISTE NINGUN INCONVENIENTE
		ELSE

            # SI ES MENU
            IF !ISNULL( _idDetalleOrdenMenu ) THEN
				UPDATE detalleOrdenMenu SET idEstadoDetalleOrden = 6 
					WHERE idDetalleOrdenMenu = _idDetalleOrdenMenu 		AND idEstadoDetalleOrden = 4;

			# SI ES COMBO
			ELSE
				UPDATE detalleOrdenCombo SET idEstadoDetalleOrden = 6
					WHERE idDetalleOrdenCombo = _idDetalleOrdenCombo 	AND idEstadoDetalleOrden = 4;
					
				# ACTUALIZA LOS ESTADOS DETALLE DE COMBO
				UPDATE detalleOrdenMenu AS dom

					JOIN detalleComboMenu AS dcm
						ON dom.idDetalleOrdenMenu = dcm.idDetalleOrdenMenu
							AND dcm.idDetalleOrdenCombo = _idDetalleOrdenCombo
							AND dom.idEstadoDetalleOrden = 4

				SET dom.idEstadoDetalleOrden = 6;
			END IF;
            
            # VERIFICA ESTADO DE ORDEN CLIENTE
            CALL cambioEstadoOrdenCliente( _idOrdenCliente, 6 );
            
            # GUARDAR DETALLE DE FACTURA
			INSERT INTO detalleOrdenFactura
				( idFactura, idDetalleOrdenMenu, idDetalleOrdenCombo, precioMenu, descuento, comentario, usuario, fechaRegistro ) 
			VALUES
				( _idFactura, _idDetalleOrdenMenu, _idDetalleOrdenCombo, _precioMenu, _descuento, _comentario, @usuario, NOW() );
				
			SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
		END IF;
	
    ELSEIF _action = 'update' THEN
		UPDATE detalleOrdenFactura SET
			precioMenu = _precioMenu,
            descuento  = _descuento,
            comentario = _comentario
		WHERE idFactura = _idFactura AND idDetalleOrdenMenu = _idDetalleOrdenMenu 
			AND idDetalleOrdenCombo = _idDetalleOrdenCombo;
    
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
        
	ELSEIF _action = 'delete' THEN

		IF !ISNULL( _idDetalleOrdenMenu ) THEN
			UPDATE detalleOrdenMenu SET idEstadoDetalleOrden = 4 
				WHERE idDetalleOrdenMenu = _idDetalleOrdenMenu;

		ELSE
			UPDATE detalleOrdenCombo SET idEstadoDetalleOrden = 4
				WHERE idDetalleOrdenCombo = _idDetalleOrdenCombo;
		END IF;

		DELETE FROM detalleOrdenFactura WHERE idFactura = _idFactura 
			AND idDetalleOrdenMenu = _idDetalleOrdenMenu AND idDetalleOrdenCombo = _idDetalleOrdenCombo;
    
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';
    
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaMenuEvento
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaMenuEvento( _action VARCHAR(15), _idEventoMenu INT, _idEvento INT, _idMenu INT, _cantidad INT, _horaDespacho TIME, _precioUnitario DOUBLE( 10,2 ), _comentario TEXT )
COMMENT 'INSERTAR / ACTUALIZAR / ELIMINAR MENU DE EVENTO'
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
    IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO eventoMenu( idEvento, idMenu, cantidad, horaDespacho, precioUnitario, fechaRegistro, usuario, comentario ) 
			VALUES ( _idEvento, _idMenu, _cantidad, _horaDespacho, _precioUnitario, NOW(), @usuario, _comentario );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
        
    ELSEIF _action = 'update' THEN
		UPDATE eventoMenu SET
			idMenu         = _idMenu,
			cantidad       = _cantidad,
			horaDespacho   = _horaDespacho,
			precioUnitario = _precioUnitario,
			comentario     = _comentario
		WHERE idEventoMenu = _idEventoMenu;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
	
	ELSEIF _action = 'delete' AND @isAdmin THEN
		DELETE FROM eventoMenu WHERE idEventoMenu = _idEventoMenu;
		
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida o no tiene acceso' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaComboEvento
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaComboEvento( _action VARCHAR(15), _idEventoCombo INT, _idEvento INT, _idCombo INT, _cantidad INT, _horaDespacho TIME, _precioUnitario DOUBLE( 10,2 ), _comentario TEXT )
COMMENT 'INSERTAR / ACTUALIZAR / ELIMINAR COMBO DE EVENTO'
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
    IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO eventoCombo( idEvento, idCombo, cantidad, horaDespacho, precioUnitario, fechaRegistro, usuario, comentario ) 
			VALUES ( _idEvento, _idCombo, _cantidad, _horaDespacho, _precioUnitario, NOW(), @usuario, comentario );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
        
    ELSEIF _action = 'update' THEN
		UPDATE eventoCombo SET
			idCombo        = _idCombo,
			cantidad       = _cantidad,
			horaDespacho   = _horaDespacho,
			precioUnitario = _precioUnitario,
			comentario     = _comentario
		WHERE idEventoCombo = _idEventoCombo;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
	
	ELSEIF _action = 'delete' AND @isAdmin THEN
		DELETE FROM eventoCombo WHERE idEventoCombo = _idEventoCombo;
		
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaOtroMenuEvento
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaOtroMenuEvento( _action VARCHAR(15), _idOtroMenu INT, _idEvento INT, _otroMenu VARCHAR(45), _cantidad INT, _horaDespacho TIME, _precioUnitario DOUBLE( 10,2 ), _comentario TEXT )
COMMENT 'INSERTAR / ACTUALIZAR / ELIMINAR OTRO COMBO DE EVENTO'
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
    IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO otroMenu( idEvento, otroMenu, cantidad, horaDespacho, precioUnitario, fechaRegistro, usuario, comentario ) 
			VALUES ( _idEvento, _otroMenu, _cantidad, _horaDespacho, _precioUnitario, NOW(), @usuario, _comentario );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
        
    ELSEIF _action = 'update' THEN
		UPDATE otroMenu SET
			otroMenu       = _otroMenu,
			cantidad       = _cantidad,
			horaDespacho   = _horaDespacho,
			precioUnitario = _precioUnitario,
			comentario     = _comentario
		WHERE idOtroMenu = _idOtroMenu;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
	
	ELSEIF _action = 'delete' AND @isAdmin THEN
		DELETE FROM otroMenu WHERE idOtroMenu = _idOtroMenu;
		
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaDetalleOrdenEvento
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaDetalleOrdenEvento( _idEvento INT )
COMMENT 'CONSULTAR DETALLE ORDEN'
BEGIN
    IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSE
		
		# DETALLE DE MENU
		(SELECT
			em.idEventoMenu AS 'id',
			em.cantidad,
			TIME_FORMAT( em.horaDespacho, '%H:%i' ) AS 'horaDespacho',
			em.precioUnitario,
			( em.cantidad * em.precioUnitario )AS 'subTotal',
			em.fechaRegistro,
			em.comentario,
			m.idMenu AS 'idMenu',
			m.menu AS 'menu',
			m.imagen,
			'menu' AS 'idTipo',
			'Menú' AS 'tipo'
		FROM eventoMenu AS em
			JOIN lstMenu AS m
				ON em.idMenu = m.idMenu
		WHERE em.idEvento = _idEvento)
			UNION ALL
		# DETALLE DE COMBO
		(SELECT
			ec.idEventoCombo AS 'id',
			ec.cantidad,
            TIME_FORMAT( ec.horaDespacho, '%H:%i' ) AS 'horaDespacho',
			ec.precioUnitario,
			( ec.cantidad * ec.precioUnitario )AS 'subTotal',
			ec.fechaRegistro,
			ec.comentario,
			c.idCombo AS 'idMenu',
			c.combo AS 'menu',
			c.imagen,
			'combo' AS 'idTipo',
			'Combo' AS 'tipo'
		FROM eventoCombo AS ec
			JOIN lstCombo AS c
				ON ec.idCombo = c.idCombo
		WHERE ec.idEvento = _idEvento)
			UNION ALL
		# DETALLE DE MENU PERSONALIZADO
		(SELECT
			idOtroMenu AS 'id',
			cantidad,
			TIME_FORMAT( horaDespacho, '%H:%i' ) AS 'horaDespacho',
			precioUnitario,
			( cantidad * precioUnitario )AS 'subTotal',
			fechaRegistro,
			comentario,
			NULL AS 'idMenu',
			otroMenu AS 'menu',
			'' AS 'imagen',
			'otroMenu' AS 'idTipo',
			'Otro Menú' AS 'tipo'
		FROM otroMenu
		WHERE idEvento = _idEvento)
        UNION ALL
        # DETALLE DE OTRO SERVICIO
		(SELECT
			idOtroServicio AS 'id',
			cantidad,
			NULL AS 'horaDespacho',
			precioUnitario,
			( cantidad * precioUnitario )AS 'subTotal',
			fechaRegistro,
			comentario,
			NULL AS 'idMenu',
			otroServicio AS 'menu',
			'' AS 'imagen',
			'otroServicio' AS 'idTipo',
			'Otro Servicio' AS 'tipo'
		FROM otroServicio
		WHERE idEvento = _idEvento)
        ORDER BY fechaRegistro ASC;
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaFacturaCompra
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaFacturaCompra( _action VARCHAR(20), _idFacturaCompra INT, _idEstadoFactura INT, _noFactura VARCHAR(15), _proveedor VARCHAR(45), _fechaFactura DATE, _comentario TEXT )
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO facturaCompra( idEstadoFactura, noFactura, proveedor, fechaFactura, comentario )
			VALUES ( _idEstadoFactura, _noFactura, _proveedor, _fechaFactura, _comentario );
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';

	ELSEIF _action = 'update' THEN
		UPDATE facturaCompra SET
			idEstadoFactura = _idEstadoFactura,
			noFactura       = _noFactura,
			proveedor       = _proveedor,
			fechaFactura    = _fechaFactura,
			comentario      = _comentario
		WHERE idFacturaCompra = _idFacturaCompra;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaFacturaCliente
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaFacturaCliente( _action VARCHAR(15), _idFactura INT, _idEstadoFactura INT, _idCliente INT, 
	_idCaja INT, _nombre VARCHAR(60), _direccion VARCHAR(75), _total DOUBLE(12,2), _descripcion VARCHAR(125) )
BEGIN
    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';
    
	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO factura
			( idEstadoFactura, idCliente, idCaja, nombre, direccion, total, fechaFactura, fechaRegistro, usuario, descripcion ) 
		VALUES
			( IFNULL( _idEstadoFactura, 1 ), _idCliente, _idCaja, _nombre, _direccion, _total, CURDATE(), NOW(), @usuario, _descripcion );
			
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
	
    ELSEIF _action = 'update' THEN
		UPDATE factura SET
			idCliente 	= _idCliente,
            nombre 	  	= _nombre,
            direccion 	= _direccion,
            total 	  	= _total,
            descripcion = _descripcion
		WHERE idFactura = _idFactura;
    
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
        
	ELSEIF _action = 'status' THEN
		# SI NO ES ADMINISTRADOR Y ES CANCELAR FACTURA
		IF @idPerfil != 1 AND _idEstadoFactura = 10 THEN
			SELECT 'danger' AS 'respuesta', 'No tiene acceso para cancelar la factura' AS 'mensaje';
            
        ELSE
			UPDATE factura SET idEstadoFactura = _idEstadoFactura
			WHERE idFactura = _idFactura;
            
            SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
            
		END IF;
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- function obtenerDisponiblidad
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE FUNCTION obtenerDisponiblidad( _idMenu INT, _idCombo INT, _cantidad INT )
RETURNS TEXT
BEGIN
	DECLARE _resultado TEXT;
    
	IF !ISNULL( _idMenu ) AND _cantidad > 0 THEN
		SELECT
			GROUP_CONCAT(
				CONCAT(
					( r.cantidad * _cantidad ), '#i#',
					p.disponibilidad, '#i#',
					p.producto, '#i#',
					m.medida
				) SEPARATOR '=r='
			) 	 INTO 	_resultado
		FROM receta AS r
			
			JOIN producto AS p
				ON r.idProducto = p.idProducto
				
			JOIN medida AS m
				ON m.idMedida = p.idMedida
                
		WHERE r.idMenu = _idMenu AND p.disponibilidad < ( r.cantidad * _cantidad ) LIMIT 1;
        
	ELSEIF !ISNULL( _idCombo ) AND _cantidad > 0 THEN
		
        SELECT
			GROUP_CONCAT(
				CONCAT(
					( cd.cantidad * r.cantidad * _cantidad ), '#i#',
					p.disponibilidad, '#i#',
					p.producto, '#i#',
					m.medida
				) SEPARATOR '=r='
			) 	 INTO 	_resultado
		FROM comboDetalle AS cd
			
            JOIN receta AS r
				ON r.idMenu = cd.idMenu
			
			JOIN producto AS p
				ON r.idProducto = p.idProducto
				
			JOIN medida AS m
				ON m.idMedida = p.idMedida
                
		WHERE cd.idCombo = _idCombo AND p.disponibilidad < ( cd.cantidad * r.cantidad * _cantidad ) LIMIT 1;
        
	END IF;

	RETURN _resultado;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaDenominacionCaja
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaDenominacionCaja( _action VARCHAR(15), _idCaja INT, _idEstadoCaja INT, _denominacion DOUBLE(5,2), _cantidad INT )
BEGIN
    DECLARE EXIT HANDLER FOR 1062
        SELECT 'danger' AS 'respuesta', 'Ya se registro la denominación para este estado' AS 'mensaje';
        
    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

    IF _action = 'insert' THEN
		INSERT INTO denominacionCaja( idCaja, idEstadoCaja, denominacion, cantidad ) 
			VALUES ( _idCaja, _idEstadoCaja, _denominacion, _cantidad );
			
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';
        
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
end$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaOtroServicio
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaOtroServicio( _action VARCHAR(15), _idOtroServicio INT, _idEvento INT, _otroServicio VARCHAR(45), _cantidad INT, _precioUnitario DOUBLE( 10,2 ), _comentario TEXT )
COMMENT 'INSERTAR / ACTUALIZAR / ELIMINAR OTRO SERVICIO DE EVENTO'
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error al guardar la información' AS 'mensaje';
	
    IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO otroServicio( idEvento, otroServicio, cantidad, precioUnitario, fechaRegistro, usuario, comentario ) 
			VALUES ( _idEvento, _otroServicio, _cantidad, _precioUnitario, NOW(), @usuario, _comentario );

		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
        
    ELSEIF _action = 'update' THEN
		UPDATE otroServicio SET
			otroServicio   = _otroServicio,
			cantidad       = _cantidad,
			precioUnitario = _precioUnitario,
			comentario     = _comentario
		WHERE idOtroServicio = _idOtroServicio;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';
	
	ELSEIF _action = 'delete' AND @isAdmin THEN
		DELETE FROM otroServicio WHERE idOtroServicio = _idOtroServicio;
		
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';

    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaMovimiento
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaMovimiento( _action VARCHAR(15), _idMovimiento INT, _idTipoMovimiento INT, 
	_idEstadoMovimiento INT, _idFormaPago INT, _idEvento INT, _motivo VARCHAR(60), _monto DOUBLE(10,2), _comentario TEXT )
BEGIN
	DECLARE _idCaja INT;

    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';
    
    SET @comentario = _comentario;
    
    # SI TIENE UNA APERTURA PENDIENTE
	SELECT idCaja INTO _idCaja FROM caja WHERE usuario = @usuario AND idEstadoCaja = 1 ORDER BY idCaja DESC LIMIT 1;
    
	# SI LA SESION ES INVALIDA
    IF !sesionValida() THEN
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';
	
    # SI LA CAJA NO ESTA HABILITADA
	ELSEIF ISNULL( _idCaja ) THEN
		SELECT 'danger' AS 'respuesta', 'No tiene ningúna Caja Abierta' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
    
		INSERT INTO movimiento ( idCaja, idTipoMovimiento, idEstadoMovimiento, idFormaPago, idEvento, motivo, monto ) 
		VALUES ( _idCaja, _idTipoMovimiento, _idEstadoMovimiento, _idFormaPago, _idEvento, _motivo, _monto );
			
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';
	 
    ELSEIF _action = 'delete' AND @isAdmin THEN
    
		DELETE FROM movimiento WHERE idMovimiento = _idMovimiento;
			
		SELECT 'success' AS 'respuesta', 'Eliminado correctamente' AS 'mensaje';
    
    ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
    END IF;
end$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure detalleFacturaEvento
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE detalleFacturaEvento( _idFactura INT, _idEvento INT )
BEGIN
	DECLARE _perteneceCombo BOOLEAN DEFAULT FALSE;
    DECLARE _estadoActualDetalle INT;
    DECLARE _idTipoServicio INT;
    # OTHERS ERRORS
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

    # MENUS DEL EVENTO
    INSERT INTO eventoFactura
    	( idEvento, idFactura, cantidad, descripcion, subTotal, fechaRegistro ) 
    SELECT
    	_idEvento, _idFactura, em.cantidad, m.menu, ( em.cantidad * em.precioUnitario), NOW()
    FROM eventoMenu AS em
    	JOIN menu AS m 		ON em.idMenu = m.idMenu
    WHERE em.idEvento = _idEvento;

    # COMBOS DEL EVENTO
    INSERT INTO eventoFactura
    	( idEvento, idFactura, cantidad, descripcion, subTotal, fechaRegistro ) 
    SELECT
    	_idEvento, _idFactura, ec.cantidad, c.combo, ( ec.cantidad * ec.precioUnitario), NOW()
    FROM eventoCombo AS ec
    	JOIN combo AS c 		ON ec.idCombo = c.idCombo
    WHERE ec.idEvento = _idEvento;

    # MENU PERSONALIZADO DEL EVENTO
    INSERT INTO eventoFactura
    	( idEvento, idFactura, cantidad, descripcion, subTotal, fechaRegistro ) 
    SELECT
    	_idEvento, _idFactura, cantidad, otroMenu, ( cantidad * precioUnitario), NOW()
    FROM otroMenu
    WHERE idEvento = _idEvento;

    # OTRO SERVICIO DEL EVENTO
    INSERT INTO eventoFactura
    	( idEvento, idFactura, cantidad, descripcion, subTotal, fechaRegistro ) 
    SELECT
    	_idEvento, _idFactura, cantidad, otroServicio, ( cantidad * precioUnitario), NOW()
    FROM otroServicio
    WHERE idEvento = _idEvento;
    
    SELECT 'success' AS 'respuesta', 'Detalle de factura guardado correctamente' AS 'mensaje';
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaCuadre
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaCuadre( _idCaja INT, _idFormaPago INT )
BEGIN
	DECLARE _montoDespacho DOUBLE(10,2) DEFAULT 0;
    DECLARE _ingresos DOUBLE(10,2) DEFAULT 0;
    DECLARE _egresos DOUBLE(10,2) DEFAULT 0;
    
    SELECT  SUM( ffp.monto )AS 'montoDespacho'
		INTO _montoDespacho
	FROM caja AS c
		JOIN factura AS f 				ON c.idCaja = f.idCaja AND ( f.idEstadoFactura = 1 OR f.idEstadoFactura = 2 )
		JOIN facturaFormaPago AS ffp 	ON f.idFactura = ffp.idFactura
	WHERE c.idCaja = _idCaja AND IF( !ISNULL( _idFormaPago ), ffp.idFormaPago = _idFormaPago, TRUE );

	SELECT SUM( IF( tm.ingreso, m.monto, 0 ) )AS 'ingresos', SUM( IF( !tm.ingreso, m.monto, 0 ) )AS 'egresos'
		INTO _ingresos, _egresos
	FROM caja AS c
		JOIN movimiento AS m 		ON c.idCaja = m.idCaja
		JOIN tipoMovimiento AS tm 	ON m.idTipoMovimiento = tm.idTipoMovimiento
	WHERE c.idCaja = _idCaja AND IF( !ISNULL( _idFormaPago ), m.idFormaPago = _idFormaPago, TRUE ) ;
    
    SELECT _montoDespacho AS 'montoDespacho', _ingresos AS 'ingresos', _egresos AS 'egresos';
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaCuadreProductoDetalle
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaCuadreProductoDetalle( _action VARCHAR(20), _idCuadreProducto INT, _idProducto INT, _cantidadApertura DOUBLE(10,2), _cantidadCierre DOUBLE(10,2), _diferenciaApertura DOUBLE(10,2), _diferenciaCierre DOUBLE(10,2), _actualizarDisponibilidad BOOLEAN, _idEstadoCuadre INT, _comentarioApertura TEXT, _comentarioCierre TEXT )
BEGIN
	DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO cuadreProductoDetalle ( idCuadreProducto, idProducto, cantidadApertura, cantidadCierre, diferenciaApertura, diferenciaCierre, comentarioApertura )
			VALUES ( _idCuadreProducto, _idProducto, _cantidadApertura, _cantidadCierre, _diferenciaApertura, _diferenciaCierre, _comentarioApertura );

		# SI ACTUALIZA DISPONIBILIDAD DE PRODUCTO
		IF _actualizarDisponibilidad AND _idEstadoCuadre = 3 THEN
			UPDATE producto SET disponibilidad = _cantidadCierre WHERE idProducto = _idProducto;
		END IF;
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje';

	ELSEIF _action = 'update' THEN
		UPDATE cuadreProductoDetalle SET
			cantidadCierre   = _cantidadCierre,
			diferenciaCierre = _diferenciaCierre,
			comentarioCierre = _comentarioCierre
		WHERE idCuadreProducto = _idCuadreProducto AND idProducto = _idProducto;

		# SI ACTUALIZA DISPONIBILIDAD DE PRODUCTO
		IF _actualizarDisponibilidad THEN
			UPDATE producto SET disponibilidad = _cantidadCierre WHERE idProducto = _idProducto;
		END IF;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaCuadreDiario
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaCuadreDiario( _action VARCHAR(20), _idCierreDiario INT, _fechaCierre DATE, _comentario TEXT, _todos BOOLEAN )
BEGIN
	DECLARE CONTINUE HANDLER FOR 1062
		SELECT 'info' AS 'respuesta', 'Error, ya se ha realizado el cierre de este día' AS 'mensaje';
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO cierreDiario ( fechaCierre, comentario, usuario, fechaRegistro, todos )
			VALUES ( _fechaCierre, _comentario, @usuario, NOW(), _todos );
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';

	ELSEIF _action = 'update' THEN
		UPDATE cierreDiario SET 
			fechaCierre = _fechaCierre,
			comentario  = _comentario
		WHERE idCierreDiario = _idCierreDiario;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure consultaCuadreProducto
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE consultaCuadreProducto( _action VARCHAR(20), _idCuadreProducto INT, _fechaCuadre DATE, _comentario TEXT, _todos BOOLEAN, _idUbicacion CHAR(1), _idEstadoCuadre INT )
BEGIN
	DECLARE CONTINUE HANDLER FOR 1062
		SELECT 'info' AS 'respuesta', 'Error, ya se ha realizado el cierre de este día' AS 'mensaje';
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
		SELECT 'danger' AS 'respuesta', 'Ocurrio un error desconocido' AS 'mensaje';

	IF !sesionValida() THEN # SI LA SESION ES INVALIDA
		SELECT 'danger' AS 'respuesta', 'Sesión no válida' AS 'mensaje';

	ELSEIF _action = 'insert' THEN
		INSERT INTO cuadreProducto ( fechaCuadre, comentario, usuario, fechaRegistro, todos, idUbicacion, idEstadoCuadre )
			VALUES ( _fechaCuadre, _comentario, @usuario, NOW(), _todos, _idUbicacion, _idEstadoCuadre );
		
		SELECT 'success' AS 'respuesta', 'Guardado correctamente' AS 'mensaje', LAST_INSERT_ID() AS 'id';

	ELSEIF _action = 'update' THEN
		UPDATE cuadreProducto SET 
			fechaCuadre    = _fechaCuadre,
			comentario     = _comentario,
			idEstadoCuadre = _idEstadoCuadre
		WHERE idCuadreProducto = _idCuadreProducto;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';

	ELSEIF _action = 'status' THEN
		UPDATE cuadreProducto SET idEstadoCuadre = _idEstadoCuadre
		WHERE idCuadreProducto = _idCuadreProducto;
		
		SELECT 'success' AS 'respuesta', 'Actualizado correctamente' AS 'mensaje';

	ELSE
		SELECT 'danger' AS 'respuesta', 'Acción no válida' AS 'mensaje';
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure cambioEstadoOrdenCliente
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE cambioEstadoOrdenCliente( _idOrdenCliente INT, _idEstadoDetalleOrden INT )
BEGIN
	DECLARE _numEstadoAnterior INT;
	DECLARE _sinFacturar INT DEFAULT 0;
	DECLARE _idFactura INT;
	DECLARE _aDomicilio BOOLEAN DEFAULT FALSE;

	# NUMERO DE ORDENES CON ESTADO ANTERIOR
    SELECT COUNT( * ) INTO _numEstadoAnterior
		FROM detalleOrdenMenu
	WHERE idOrdenCliente = _idOrdenCliente AND idEstadoDetalleOrden < _idEstadoDetalleOrden;

    # CAMBIA ESTADO A ORDEN PRINCIPAL SI TODOS CAMBIARON
    IF _numEstadoAnterior = 0 THEN
		UPDATE ordenCliente SET idEstadoOrden = _idEstadoDetalleOrden
			WHERE idOrdenCliente = _idOrdenCliente AND idEstadoOrden < _idEstadoDetalleOrden;

		# ESTADOS: 4, 6
		IF _idEstadoDetalleOrden >= 4 AND _idEstadoDetalleOrden < 10 THEN

			# VERIFICA NUMERO DE ORDENES SIN FACTURAR
			SELECT
				COUNT( IF( ISNULL( fac.idFactura ), 1, NULL ) ),
    			fac.idFactura 
    				INTO
    			_sinFacturar,
    			_idFactura
			FROM
			((SELECT dom.idDetalleOrdenMenu, dof.idFactura
				FROM detalleOrdenMenu AS dom
					LEFT JOIN detalleOrdenFactura AS dof
						ON dom.idDetalleOrdenMenu = dof.idDetalleOrdenMenu
			WHERE idOrdenCliente = _idOrdenCliente AND !perteneceCombo AND idEstadoDetalleOrden != 10)
			UNION ALL
			(SELECT doc.idDetalleOrdenCombo, dof.idFactura
				FROM detalleOrdenCombo AS doc
					LEFT JOIN detalleOrdenFactura AS dof
						ON doc.idDetalleOrdenCombo = dof.idDetalleOrdenCombo
			WHERE idOrdenCliente = _idOrdenCliente AND idEstadoDetalleOrden != 10))fac ;

			# VERIFICA SI ES A DOMICILIO
			SELECT 
				IF( COUNT( IF( idTipoServicio = 3, 1, NULL ) ) = COUNT( * ),
					TRUE,
			        FALSE
			    ) INTO _aDomicilio
			FROM detalleOrdenMenu
			WHERE idOrdenCliente = _idOrdenCliente AND idEstadoDetalleOrden != 10;

			# SI TODOS YA ESTAN FACTURADOS, ACTUALIZA ESTADO DE ORDENES A FACTURADOS
			IF _idEstadoDetalleOrden = 4 AND _sinFacturar = 0 THEN
				UPDATE detalleOrdenMenu SET idEstadoDetalleOrden = 6
				WHERE idOrdenCliente = _idOrdenCliente AND idEstadoDetalleOrden < 6;

				UPDATE detalleOrdenCombo SET idEstadoDetalleOrden = 6
				WHERE idOrdenCliente = _idOrdenCliente AND idEstadoDetalleOrden < 6;

				UPDATE ordenCliente SET idEstadoOrden = 6
				WHERE idOrdenCliente = _idOrdenCliente AND idEstadoOrden < 6;
			END IF;

			# TODAS LAS ORDENDES YA ESTAN FACTURADAS
			IF _aDomicilio AND _sinFacturar = 0 THEN
				UPDATE factura 
					SET idEstadoFactura = 2
				WHERE idFactura = _idFactura;

			END IF;

		END IF; # SI ES FINALIZADO
	END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure repDescuento
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE repDescuento( _deFecha DATE, _paraFecha DATE )
BEGIN
	SELECT
		f.idFactura,
		f.fechaFactura,
		c.nit,
		f.nombre,
		f.direccion,
		c.telefono,
		IF( dof.idMenuPersonalizado > 0,
			mp.cantidad,
			COUNT( dof.idFactura )
		)AS 'numeroMenus',
		IF( dof.idMenuPersonalizado > 0,
			mp.precioUnidad,
			dof.precioMenu
		)AS 'precioUnitario',
		SUM( dof.descuento )AS 'totalDescuento',
		dof.comentario,
		IFNULL( m.menu, IFNULL( cm.combo, mp.descripcion ) )AS 'menu',
        u.usuario,
		CONCAT( u.nombres, ' ', u.apellidos )AS 'nombreUsuario'
    FROM factura AS f
    	JOIN cliente AS c
    		ON c.idCliente = f.idCliente

		JOIN detalleOrdenFactura AS dof
			ON dof.idFactura = f.idFactura
		
        JOIN usuario AS u
			ON u.usuario = dof.usuario

		LEFT JOIN (detalleOrdenMenu AS dom
			JOIN menu AS m  ON  dom.idMenu = m.idMenu
		) ON dom.idDetalleOrdenMenu = dof.idDetalleOrdenMenu

		LEFT JOIN (detalleOrdenCombo AS doc
			JOIN combo AS cm  ON  doc.idCombo = cm.idCombo
		) ON doc.idDetalleOrdenCombo = dof.idDetalleOrdenCombo

		LEFT JOIN menuPersonalizado AS mp
			ON mp.idMenuPersonalizado = dof.idMenuPersonalizado

	WHERE ( f.fechaFactura BETWEEN _deFecha AND _paraFecha )
		AND dof.descuento > 0
	GROUP BY
		dof.idDetalleOrdenMenu, 
		dof.idDetalleOrdenCombo,
		dof.idMenuPersonalizado
	ORDER BY f.idFactura ASC;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure repCierreCaja
-- -----------------------------------------------------

DELIMITER $$
USE `dbChurchill`$$
CREATE PROCEDURE repCierreCaja( _deFecha DATE, _paraFecha DATE )
BEGIN
	SELECT
		c.idCaja,
		c.fechaApertura,
		TIME( beca.fechaRegistro )AS 'horaApertura',
		DATE( becc.fechaRegistro )AS 'fechaCierre',
		TIME( becc.fechaRegistro )AS 'horaCierre',
		c.efectivoInicial,
		c.efectivoFinal,
		c.efectivoSobrante,
		c.efectivoFaltante,
        u.usuario,
		CONCAT( u.nombres, ' ', u.apellidos )AS 'nombre'
    FROM caja AS c
        JOIN usuario AS u
			ON u.usuario = c.usuario

		LEFT JOIN bitacoraEstadoCaja AS beca #FECHA APERTURA
			ON beca.idCaja = c.idCaja AND beca.idEstadoCaja = 1

		LEFT JOIN bitacoraEstadoCaja AS becc #FECHA CIERRE
			ON becc.idCaja = c.idCaja AND ( becc.idEstadoCaja = 2 OR becc.idEstadoCaja = 3 )

	WHERE ( c.fechaApertura BETWEEN _deFecha AND _paraFecha )
	GROUP BY c.idCaja
	ORDER BY c.idCaja ASC;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- View `dbChurchill`.`vstCliente`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vstCliente`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW vstCliente AS
SELECT idCliente, nit, nombre, cui, correo, telefono, direccion, c.idTipoCliente, tipoCliente
FROM cliente AS c
	JOIN tipoCliente AS tc ON tc.idTipoCliente = c.idTipoCliente;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstProducto`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstProducto`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstProducto AS
SELECT
	p.idProducto,
	p.producto,
	m.idMedida,
	m.medida,
	tp.idTipoProducto,
	tp.tipoProducto,
	p.perecedero,
	p.cantidadMinima,
	p.cantidadMaxima,
	p.disponibilidad,
	p.importante,
    u.idUbicacion,
    u.ubicacion,
	p.usuario AS 'usuarioProducto',
	p.fechaRegistro AS 'fechaProducto'
FROM producto AS p
	JOIN medida AS m
		ON m.idMedida = p.idMedida
        
	JOIN tipoProducto AS tp
		ON tp.idTipoProducto = p.idTipoProducto
	
    JOIN ubicacion AS u
		ON u.idUbicacion = p.idUbicacion
;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstIngresoProducto`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstIngresoProducto`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstIngresoProducto AS
SELECT
	i.idIngreso,
    i.idFacturaCompra,
	p.idProducto,
	producto,
	idMedida,
	medida,
	idTipoProducto,
	tipoProducto,
	perecedero,
	cantidadMinima,
	cantidadMaxima,
	disponibilidad,
	importante,
	i.cantidad,
    i.costo,
	i.usuario AS 'usuarioIngreso',
	i.fechaRegistro AS 'fechaIngreso'
FROM lstProducto AS p
	JOIN ingreso AS i ON i.idProducto = p.idProducto;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstReajusteProducto`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstReajusteProducto`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstReajusteProducto AS
SELECT
	r.idReajuste,
	p.idProducto,
	producto,
	idMedida,
	medida,
	idTipoProducto,
	tipoProducto,
	perecedero,
	cantidadMinima,
	cantidadMaxima,
	disponibilidad,
	importante,
	rp.cantidad,
	rp.esIncremento,
	r.observacion,
	r.usuario AS 'usuarioReajuste',
	r.fechaRegistro AS 'fechaReajuste'
FROM reajuste AS r
	JOIN reajusteProducto AS rp ON r.idReajuste = rp.idReajuste
	JOIN lstProducto AS p ON rp.idProducto = p.idProducto
;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstMenu`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstMenu`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstMenu AS
SELECT
	m.idMenu,
	m.menu,
	IFNULL( m.imagen, '' )AS 'imagen',
	m.descripcion,
	em.idEstadoMenu,
	em.estadoMenu,
	dm.idDestinoMenu,
	dm.destinoMenu,
	tm.idTipoMenu,
	tm.tipoMenu,
    m.codigo AS 'codigoMenu',
    m.tiempoAlerta,
    m.seCocina
FROM menu AS m
	JOIN estadoMenu AS em
		ON em.idEstadoMenu = m.idEstadoMenu
	JOIN destinoMenu AS dm
		ON dm.idDestinoMenu = m.idDestinoMenu
	JOIN tipoMenu AS tm
		ON m.idTipoMenu = tm.idTipoMenu
ORDER BY m.top DESC;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstReceta`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstReceta`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstReceta AS
SELECT
	r.idMenu,
	p.idProducto,
	p.producto,
	r.cantidad,
	p.medida,
	p.tipoProducto,
	r.observacion
FROM receta AS r
	JOIN lstProducto AS p
		ON p.idProducto = r.idProducto;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstMenuPrecio`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstMenuPrecio`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstMenuPrecio AS
SELECT
	mp.idMenu,
	mp.precio,
	ts.idTipoServicio,
	ts.tipoServicio
FROM menuPrecio AS mp
	JOIN tipoServicio AS ts
		ON mp.idTipoServicio = ts.idTipoServicio;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstCombo`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstCombo`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstCombo AS
SELECT
	c.idCombo,
	c.combo,
	IFNULL( c.imagen, '' )AS 'imagen',
	c.descripcion,
	em.idEstadoMenu,
	em.estadoMenu,
    c.codigo AS 'codigoCombo'
FROM combo AS c
	JOIN estadoMenu AS em
		ON c.idEstadoMenu = em.idEstadoMenu
ORDER BY c.top DESC;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstComboDetalle`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstComboDetalle`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstComboDetalle AS
SELECT
	cd.idCombo,
	cd.cantidad,
	m.idMenu,
	m.menu,
	m.imagen,
	m.descripcion,
	m.idEstadoMenu,
	m.estadoMenu
FROM comboDetalle AS cd
	JOIN lstMenu AS m
		ON m.idMenu = cd.idMenu;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstComboPrecio`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstComboPrecio`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstComboPrecio AS
SELECT
	cp.idCombo,
	cp.precio,
	ts.idTipoServicio,
	ts.tipoServicio
FROM comboPrecio AS cp
	JOIN tipoServicio AS ts
		ON cp.idTipoServicio = ts.idTipoServicio;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstSuperCombo`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstSuperCombo`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstSuperCombo AS
SELECT
	sc.idSuperCombo,
	sc.superCombo,
	IFNULL( sc.imagen, '' )AS 'imagen',
	sc.descripcion,
	em.idEstadoMenu,
	em.estadoMenu,
    sc.codigo AS 'codigoSuperCombo'
FROM superCombo AS sc
	JOIN estadoMenu AS em
		ON sc.idEstadoMenu = em.idEstadoMenu
ORDER BY sc.top DESC;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstSuperComboDetalle`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstSuperComboDetalle`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstSuperComboDetalle AS
SELECT
	scd.idSuperCombo,
	scd.cantidad,
	c.idCombo,
	c.combo,
	c.imagen,
	c.descripcion,
	c.idEstadoMenu,
	c.estadoMenu
FROM superComboDetalle AS scd
	JOIN lstCombo AS c
		ON c.idCombo = scd.idCombo;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstSuperComboPrecio`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstSuperComboPrecio`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstSuperComboPrecio AS
SELECT
	scp.idSuperCombo,
	scp.precio,
	ts.idTipoServicio,
	ts.tipoServicio
FROM superComboPrecio AS scp
	JOIN tipoServicio AS ts
		ON scp.idTipoServicio = ts.idTipoServicio;

-- -----------------------------------------------------
-- View `dbChurchill`.`_vMenuCombo`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`_vMenuCombo`;
USE `dbChurchill`;
CREATE OR REPLACE VIEW _vMenuCombo AS
SELECT
	dcm.idDetalleOrdenMenu,
	dcm.idDetalleOrdenCombo,
	cp.precio AS 'precioCombo',
	c.combo,
    c.idCombo,
    c.imagen AS 'imagenCombo',
    doc.idEstadoDetalleOrden AS 'idEstadoDetalleOrdenCombo',
    doc.observacion AS 'observacionCombo'
FROM detalleComboMenu AS dcm
	JOIN detalleOrdenCombo AS doc
		ON dcm.idDetalleOrdenCombo = doc.idDetalleOrdenCombo
	JOIN combo AS c
		ON doc.idCombo = c.idCombo
	JOIN comboPrecio AS cp
		ON doc.idTipoServicio = cp.idTipoServicio AND doc.idCombo = cp.idCombo
;

-- -----------------------------------------------------
-- View `dbChurchill`.`vOrdenes`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vOrdenes`;
USE `dbChurchill`;
CREATE OR REPLACE VIEW vOrdenes AS
SELECT
	dom.idDetalleOrdenMenu,
	oc.idOrdenCliente,
	oc.numeroTicket,
    oc.usuarioResponsable AS 'responsableOrden',
    oc.idEstadoOrden,
    oc.numeroGrupo,
	dom.cantidad,
	m.idMenu,
	m.menu,
    m.codigo AS 'codigoMenu',
    m.tiempoAlerta,
	dom.perteneceCombo,
	m.descripcion,
	IFNULL( m.imagen, '' ) AS 'imagen',
	mp.precio,
	mc.idCombo,
    mc.combo,
    mc.imagenCombo,
	mc.precioCombo,
	edo.idEstadoDetalleOrden,
	edo.estadoDetalleOrden,
	ts.idTipoServicio,
	ts.tipoServicio,
	dm.idDestinoMenu,
	dm.destinoMenu,
	dom.usuarioResponsable AS 'responsableDetalle',
    dom.usuario AS 'usuarioDetalle',
    dom.observacion,
	u.nombres,
	u.codigo,
	mc.idDetalleOrdenCombo,
    mc.idEstadoDetalleOrdenCombo,
	bom.fechaRegistro,
	bom.usuario AS 'usuarioRegistro'
FROM detalleOrdenMenu AS dom
	JOIN menu AS m
		ON dom.idMenu = m.idMenu
	JOIN estadoDetalleOrden AS edo
		ON dom.idEstadoDetalleOrden = edo.idEstadoDetalleOrden
	JOIN tipoServicio AS ts
		ON dom.idTipoServicio = ts.idTipoServicio
	JOIN usuario AS u
		ON dom.usuarioResponsable = u.usuario
	JOIN bitacoraOrdenMenu AS bom
		ON dom.idDetalleOrdenMenu = bom.idDetalleOrdenMenu AND dom.idEstadoDetalleOrden = bom.idEstadoDetalleOrden
	JOIN destinoMenu AS dm
		ON dm.idDestinoMenu = m.idDestinoMenu
	JOIN ordenCliente AS oc
		ON dom.idOrdenCliente = oc.idOrdenCliente
	LEFT JOIN menuPrecio AS mp
		ON m.idMenu = mp.idMenu AND dom.idTipoServicio = mp.idTipoServicio AND !dom.perteneceCombo
	LEFT JOIN _vMenuCombo AS mc
		ON dom.idDetalleOrdenMenu = mc.idDetalleOrdenMenu
ORDER BY dom.idDetalleOrdenMenu DESC
;

-- -----------------------------------------------------
-- View `dbChurchill`.`vOrdenCliente`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vOrdenCliente`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW vOrdenCliente AS
SELECT
	idOrdenCliente,
    numeroTicket,
    usuarioPropietario,
    usuarioResponsable,
    eo.idEstadoOrden,
    eo.estadoOrden,
    fechaRegistro,
    numMenu,
    numeroGrupo
FROM ordenCliente AS oc
	JOIN estadoOrden AS eo
		ON oc.idEstadoOrden = eo.idEstadoOrden;

-- -----------------------------------------------------
-- View `dbChurchill`.`vCuadreProducto`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vCuadreProducto`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW vCuadreProducto AS
SELECT 
	idCuadreProducto,
    fechaCuadre,
    comentario,
    usuario,
    fechaRegistro AS 'fechaRegistroCuadre',
    todos,
    u.idUbicacion,
    u.ubicacion,
    ec.idEstadoCuadre,
    ec.estadoCuadre
FROM cuadreProducto AS cp
	JOIN estadoCuadre AS ec
		ON ec.idEstadoCuadre = cp.idEstadoCuadre

	JOIN ubicacion AS u
		ON u.idUbicacion = cp.idUbicacion
;

-- -----------------------------------------------------
-- View `dbChurchill`.`vCuadreProductoDetalle`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vCuadreProductoDetalle`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW vCuadreProductoDetalle AS
SELECT 
	cp.idCuadreProducto,
    cp.fechaCuadre,
    cp.comentario,
    cp.usuario,
    cp.fechaRegistroCuadre,
    cpd.cantidadApertura,
    cpd.cantidadCierre,
    cpd.diferenciaApertura,
    cpd.diferenciaCierre,
    cpd.comentarioApertura,
    cpd.comentarioCierre,
	p.*
FROM vCuadreProducto AS cp
	JOIN cuadreProductoDetalle AS cpd
		ON cp.idCuadreProducto = cpd.idCuadreProducto
	JOIN lstProducto AS p
		ON cpd.idProducto = p.idProducto
;

-- -----------------------------------------------------
-- View `dbChurchill`.`lstFacturaCompra`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`lstFacturaCompra`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW lstFacturaCompra AS
SELECT
	fc.idFacturaCompra,
	fc.noFactura,
	fc.proveedor,
	fc.fechaFactura,
	fc.comentario,
	ef.idEstadoFactura,
	ef.estadoFactura,
	fce.usuario,
	fce.fechaRegistro
FROM facturaCompra AS fc
	JOIN facturaCompraEstado AS fce
		ON fc.idFacturaCompra = fce.idFacturaCompra AND fc.idEstadoFactura = fce.idEstadoFactura
	JOIN estadoFactura AS ef 
		ON fc.idEstadoFactura = ef.idEstadoFactura;

-- -----------------------------------------------------
-- View `dbChurchill`.`vUsuario`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vUsuario`;
USE `dbChurchill`;
CREATE OR REPLACE VIEW vUsuario AS
SELECT
	u.usuario,
    u.codigo,
    u.nombres,
    u.apellidos,
    u.fechaRegistro,
    eu.idEstadoUsuario,
    eu.estadoUsuario,
    p.idPerfil,
    p.perfil,
    u.idDestinoMenu
FROM usuario AS u
	JOIN estadoUsuario AS eu
		ON u.idEstadoUsuario = eu.idEstadoUsuario
	JOIN perfil AS p
		ON p.idPerfil = u.idPerfil;

-- -----------------------------------------------------
-- View `dbChurchill`.`vstCaja`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vstCaja`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW vstCaja AS
SELECT 
	c.idCaja,
    c.usuario,
    c.fechaApertura,
    c.efectivoInicial,
    c.efectivoFinal,
    c.efectivoSobrante,
    c.efectivoFaltante,
    ec.idEstadoCaja,
    ec.estadoCaja,
    u.nombres,
    u.apellidos,
    u.codigo
FROM caja AS c
	JOIN estadoCaja AS ec
		ON c.idEstadoCaja = ec.idEstadoCaja
	JOIN vUsuario AS u
		ON c.usuario = u.usuario;

-- -----------------------------------------------------
-- View `dbChurchill`.`vstFactura`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vstFactura`;
USE `dbChurchill`;
CREATE OR REPLACE VIEW vstFactura AS
SELECT 
	f.idFactura,
    f.idCliente,
    c.nit,
    f.idCaja,
    f.nombre,
    f.direccion,
    f.total,
    f.fechaFactura,
    f.usuario,
    ef.idEstadoFactura,
    ef.estadoFactura,
    f.fechaRegistro,
    f.descripcion,
    IF( LENGTH( f.descripcion ), 0, 1 ) AS 'siDetalle'
FROM factura AS f
	JOIN vstCliente AS c
		ON c.idCliente = f.idCliente
	JOIN estadoFactura AS ef
		ON f.idEstadoFactura = ef.idEstadoFactura;

-- -----------------------------------------------------
-- View `dbChurchill`.`vstFormaPago`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vstFormaPago`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW vstFormaPago AS
SELECT 
	ffp.idFactura,
    ffp.monto,
    fp.idFormaPago,
    fp.formaPago
FROM facturaFormaPago AS ffp
	JOIN formaPago AS fp
		ON ffp.idFormaPago = fp.idFormaPago;

-- -----------------------------------------------------
-- View `dbChurchill`.`vstDetalleOrdenFactura`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vstDetalleOrdenFactura`;
USE `dbChurchill`;
CREATE OR REPLACE VIEW vstDetalleOrdenFactura AS
SELECT
	dof.idFactura,
	mn.idOrdenCliente,
	mn.numeroTicket,
	mn.idDetalleOrdenMenu,
	mn.idMenu,
	mn.menu,
	mn.imagen,
	mn.perteneceCombo,
	mn.idDetalleOrdenCombo,
	mn.idCombo,
    mn.combo,
    mn.imagenCombo,
	mn.idTipoServicio,
	mn.tipoServicio,
	mn.usuarioRegistro,
	dof.precioMenu,
	dof.descuento,
	( dof.precioMenu - dof.descuento ) AS 'precioReal',
	dof.comentario,
	dof.usuario AS 'usuarioFacturaDetalle',
	dof.fechaRegistro AS 'fechaFacturaDetalle'
FROM vOrdenes AS mn
	JOIN detalleOrdenFactura AS dof ON 
	(
		( !ISNULL( mn.idDetalleOrdenMenu ) AND mn.idDetalleOrdenMenu = dof.idDetalleOrdenMenu )
		OR
		( !ISNULL( mn.idDetalleOrdenCombo ) AND mn.idDetalleOrdenCombo = dof.idDetalleOrdenCombo )
	)
;

-- -----------------------------------------------------
-- View `dbChurchill`.`vEvento`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vEvento`;
USE `dbChurchill`;
CREATE OR REPLACE VIEW vEvento AS
SELECT
	e.idEvento,
    e.evento,
    e.fechaEvento,
    s.idSalon,
    s.salon,
    e.horaInicio,
    e.horaFinal,
    e.observacion,
    e.usuario,
    e.fechaRegistro,
    e.numeroPersonas,
    ee.idEstadoEvento,
    ee.estadoEvento,
    c.idCliente,
    nit,
    nombre,
    cui,
    correo,
    telefono,
    direccion,
    idTipoCliente,
    tipoCliente,
    e.idFactura
FROM evento AS e
	JOIN vstCliente AS c
		ON e.idCliente = c.idCliente
        
	JOIN estadoEvento AS ee
		ON e.idEstadoEvento = ee.idEstadoEvento
	
    JOIN salon AS s
		ON s.idSalon = e.idSalon
        
;

-- -----------------------------------------------------
-- View `dbChurchill`.`vDenominacionCaja`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vDenominacionCaja`;
USE `dbChurchill`;
CREATE  OR REPLACE VIEW `vDenominacionCaja` AS
SELECT 
	idCaja,
    idEstadoCaja,
    denominacion,
    cantidad,
    ( denominacion * cantidad )AS 'monto'
FROM denominacionCaja;

-- -----------------------------------------------------
-- View `dbChurchill`.`vOtroServicio`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `dbChurchill`.`vOtroServicio`;
USE `dbChurchill`;
CREATE OR REPLACE VIEW vOtroServicio AS
SELECT
	idOtroServicio,
	idEvento,
	otroServicio,
	cantidad,
	precioUnitario,
	fechaRegistro,
	usuario
FROM otroServicio
;
USE `dbChurchill`;

DELIMITER $$
USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`usuario_BEFORE_INSERT` BEFORE INSERT ON `usuario` FOR EACH ROW
BEGIN
	SET NEW.clave = md5( NEW.clave );
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`ordenCliente_AFTER_UPDATE` AFTER UPDATE ON `ordenCliente` FOR EACH ROW
BEGIN
	IF IFNULL( OLD.idEstadoOrden, '' ) != IFNULL( NEW.idEstadoOrden, '' ) THEN
		INSERT INTO bitacoraOrdenCliente
			( idOrdenCliente, idEstadoOrden, usuario, fechaRegistro, comentario )
		VALUES( NEW.idOrdenCliente, NEW.idEstadoOrden, @usuario, NOW(), @comentario );
        
        SET @comentario = NULL;
	END IF;
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER dbChurchill.detalleOrdenMenu_AFTER_INSERT AFTER INSERT ON detalleOrdenMenu FOR EACH ROW
BEGIN
	INSERT INTO bitacoraOrdenMenu(idEstadoDetalleOrden, idDetalleOrdenMenu, fechaRegistro, usuario) 
		VALUES (NEW.idEstadoDetalleOrden, NEW.idDetalleOrdenMenu, now(), @usuario);
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`detalleOrdenMenu_AFTER_UPDATE` AFTER UPDATE ON `detalleOrdenMenu` FOR EACH ROW
BEGIN
	DECLARE _ordenesPendientes INT DEFAULT 0;
    
	IF IFNULL( OLD.idEstadoDetalleOrden, '' ) != IFNULL( NEW.idEstadoDetalleOrden, '' ) THEN
		INSERT INTO bitacoraOrdenMenu(idEstadoDetalleOrden, idDetalleOrdenMenu, fechaRegistro, usuario, comentario ) 
			VALUES (NEW.idEstadoDetalleOrden, NEW.idDetalleOrdenMenu, now(), @usuario, @comentario );

	END IF;
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER dbChurchill.detalleOrdenCombo_AFTER_INSERT AFTER INSERT ON detalleOrdenCombo FOR EACH ROW
BEGIN
	INSERT INTO bitacoraOrdenCombo(idEstadoDetalleOrden, idDetalleOrdenCombo, fechaRegistro, usuario) 
		VALUES (NEW.idEstadoDetalleOrden, NEW.idDetalleOrdenCombo, now(), @usuario);
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`detalleOrdenCombo_AFTER_UPDATE` AFTER UPDATE ON `detalleOrdenCombo` FOR EACH ROW
BEGIN
	IF IFNULL( OLD.idEstadoDetalleOrden, '' ) != IFNULL( NEW.idEstadoDetalleOrden, '' ) THEN
		INSERT INTO bitacoraOrdenCombo(idEstadoDetalleOrden, idDetalleOrdenCombo, fechaRegistro, usuario, comentario ) 
			VALUES (NEW.idEstadoDetalleOrden, NEW.idDetalleOrdenCombo, now(), @usuario, @comentario );
	END IF;
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`facturaCompra_AFTER_INSERT` AFTER INSERT ON `facturaCompra` FOR EACH ROW
BEGIN
	INSERT INTO facturaCompraEstado( idFacturaCompra, idEstadoFactura, usuario, fechaRegistro ) 
		VALUES( NEW.idFacturaCompra, NEW.idEstadoFactura, @usuario, NOW() );
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`facturaCompra_AFTER_UPDATE` AFTER UPDATE ON `facturaCompra` FOR EACH ROW
BEGIN
	IF IFNULL( OLD.idEstadoFactura, '' ) != IFNULL( NEW.idEstadoFactura, '' ) THEN
		INSERT INTO facturaCompraEstado( idFacturaCompra, idEstadoFactura, usuario, fechaRegistro ) 
			VALUES( NEW.idFacturaCompra, NEW.idEstadoFactura, @usuario, NOW() );
    END IF;
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`ingreso_AFTER_INSERT` AFTER INSERT ON `ingreso` FOR EACH ROW
BEGIN
	INSERT INTO bitacoraIngreso ( idProducto, cantidad, accion, fechaRegistro, usuario )
		VALUES ( NEW.idProducto, NEW.cantidad, 'insert', NOW(), @usuario );
	
    UPDATE producto SET disponibilidad = disponibilidad + NEW.cantidad 
		WHERE idProducto = NEW.idProducto;
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`ingreso_AFTER_DELETE` AFTER DELETE ON `ingreso` FOR EACH ROW
BEGIN
	INSERT INTO bitacoraIngreso ( idProducto, cantidad, accion, fechaRegistro, usuario )
		VALUES ( OLD.idProducto, OLD.cantidad, 'delete', NOW(), @usuario );
	
    UPDATE producto SET disponibilidad = disponibilidad - OLD.cantidad 
		WHERE idProducto = OLD.idProducto;
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`caja_AFTER_INSERT` AFTER INSERT ON `caja` FOR EACH ROW
BEGIN
	INSERT INTO bitacoraEstadoCaja( idCaja, idEstadoCaja, fechaRegistro, usuario ) 
		VALUES ( NEW.idCaja, NEW.idEstadoCaja, NOW(), @usuario );
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`caja_AFTER_UPDATE` AFTER UPDATE ON `caja` FOR EACH ROW
BEGIN
	INSERT INTO bitacoraEstadoCaja( idCaja, idEstadoCaja, fechaRegistro, usuario ) 
		VALUES ( NEW.idCaja, NEW.idEstadoCaja, NOW(), @usuario );
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`factura_AFTER_INSERT` AFTER INSERT ON `factura` FOR EACH ROW
BEGIN
	INSERT INTO bitacoraEstadoFactura ( idFactura, idEstadoFactura, usuario, fechaRegistro ) 
		VALUES( NEW.idFactura, NEW.idEstadoFactura, @usuario, NOW() );
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`factura_AFTER_UPDATE` AFTER UPDATE ON `factura` FOR EACH ROW
BEGIN
	INSERT INTO bitacoraEstadoFactura ( idFactura, idEstadoFactura, comentario, usuario, fechaRegistro ) 
		VALUES( NEW.idFactura, NEW.idEstadoFactura, @comentario, @usuario, NOW() );
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`evento_AFTER_INSERT` AFTER INSERT ON `evento` FOR EACH ROW
BEGIN

	INSERT INTO bitacoraEstadoEvento ( idEstadoEvento, idEvento, comentario, usuario, fechaRegistro )
		VALUES( NEW.idEstadoEvento, NEW.idEvento, IFNULL( @comentario, '' ), @usuario, NOW() );

END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`evento_AFTER_UPDATE` AFTER UPDATE ON `evento` FOR EACH ROW
BEGIN
	IF OLD.idEstadoEvento != NEW.idEstadoEvento THEN
		INSERT INTO bitacoraEstadoEvento ( idEstadoEvento, idEvento, comentario, usuario, fechaRegistro )
			VALUES( NEW.idEstadoEvento, NEW.idEvento, IFNULL( @comentario, '' ), @usuario, NOW() );
	END IF;
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`movimiento_AFTER_INSERT` AFTER INSERT ON `movimiento` FOR EACH ROW
BEGIN
	INSERT INTO logEstadoMovimiento ( idMovimiento, idEstadoMovimiento, fechaRegistro, usuario, comentario ) 
		VALUES( NEW.idMovimiento, NEW.idEstadoMovimiento, NOW(), @usuario, @comentario );
END$$

USE `dbChurchill`$$
CREATE DEFINER = CURRENT_USER TRIGGER `dbChurchill`.`movimiento_AFTER_UPDATE` AFTER UPDATE ON `movimiento` FOR EACH ROW
BEGIN
	IF OLD.idEstadoMovimiento != NEW.idEstadoMovimiento THEN
    
		INSERT INTO logEstadoMovimiento ( idMovimiento, idEstadoMovimiento, fechaRegistro, usuario, comentario ) 
			VALUES( NEW.idMovimiento, NEW.idEstadoMovimiento, NOW(), @usuario, @comentario );
	
    END IF;
END$$


DELIMITER ;

SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;

-- -----------------------------------------------------
-- Data for table `dbChurchill`.`estadoUsuario`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`estadoUsuario` (`idEstadoUsuario`, `estadoUsuario`) VALUES (1, 'Activo');
INSERT INTO `dbChurchill`.`estadoUsuario` (`idEstadoUsuario`, `estadoUsuario`) VALUES (2, 'Bloqueado');
INSERT INTO `dbChurchill`.`estadoUsuario` (`idEstadoUsuario`, `estadoUsuario`) VALUES (3, 'Deshabilitado');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`perfil`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`perfil` (`idPerfil`, `perfil`) VALUES (1, 'Administrador');
INSERT INTO `dbChurchill`.`perfil` (`idPerfil`, `perfil`) VALUES (2, 'Cajero');
INSERT INTO `dbChurchill`.`perfil` (`idPerfil`, `perfil`) VALUES (3, 'Cocinero');
INSERT INTO `dbChurchill`.`perfil` (`idPerfil`, `perfil`) VALUES (4, 'Barra');
INSERT INTO `dbChurchill`.`perfil` (`idPerfil`, `perfil`) VALUES (5, 'Mesero');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`destinoMenu`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`destinoMenu` (`idDestinoMenu`, `destinoMenu`) VALUES (1, 'Cocina');
INSERT INTO `dbChurchill`.`destinoMenu` (`idDestinoMenu`, `destinoMenu`) VALUES (2, 'Barra');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`usuario`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`usuario` (`usuario`, `idEstadoUsuario`, `idPerfil`, `idDestinoMenu`, `codigo`, `clave`, `nombres`, `apellidos`, `usuarioRegistro`, `fechaRegistro`) VALUES ('restaurante', 1, 1, 1, 100, '123456', 'Pollo', 'Churchill', NULL, '2017-01-01 23:59:59');
INSERT INTO `dbChurchill`.`usuario` (`usuario`, `idEstadoUsuario`, `idPerfil`, `idDestinoMenu`, `codigo`, `clave`, `nombres`, `apellidos`, `usuarioRegistro`, `fechaRegistro`) VALUES ('usuarioBarra', 1, 4, 2, 200, '0987', 'Usuario', 'Barra', NULL, '2017-01-01 23:59:59');
INSERT INTO `dbChurchill`.`usuario` (`usuario`, `idEstadoUsuario`, `idPerfil`, `idDestinoMenu`, `codigo`, `clave`, `nombres`, `apellidos`, `usuarioRegistro`, `fechaRegistro`) VALUES ('usuarioCocina', 1, 3, 1, 300, '0987', 'Usuario', 'Cocina', NULL, '2017-01-01 23:59:59');
INSERT INTO `dbChurchill`.`usuario` (`usuario`, `idEstadoUsuario`, `idPerfil`, `idDestinoMenu`, `codigo`, `clave`, `nombres`, `apellidos`, `usuarioRegistro`, `fechaRegistro`) VALUES ('joseIbarra', 1, 4, 2, 400, '0987', 'Jose', 'Ibarra', NULL, '2017-01-01 23:59:59');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`modulo`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (1, 'ordenes', 'orden', 'img/orden.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (2, 'Admin. Orden', 'adminOrden', 'orden1.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (3, 'Facturacion', 'factura', 'img/factura.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (4, 'Eventos', 'evento', 'img/evento.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (5, 'Clientes', 'cliente', 'img/cliente.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (6, 'Caja', 'caja', 'img/caja.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (7, 'Inventario', 'inventario', 'img/inventario.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (8, 'Promociones', 'promocion', 'img/promocion.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (9, 'Administracion', 'admin', 'img/admins.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (10, 'Mantenimientos', 'mantenimiento', 'img/mantenimiento.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (11, 'Tendencias', 'tendencia', 'img/tendencia.png', 1);
INSERT INTO `dbChurchill`.`modulo` (`idModulo`, `modulo`, `ruta`, `img`, `habilitado`) VALUES (12, 'Reportes', 'reporte', 'img/reporte.png', 1);

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`perfilModulo`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 1);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 2);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 3);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 4);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 5);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 6);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 7);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 8);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 9);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 10);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 11);
INSERT INTO `dbChurchill`.`perfilModulo` (`idPerfil`, `idModulo`) VALUES (1, 12);

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`tipoRespuesta`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`tipoRespuesta` (`idTipoRespuesta`, `tipoRespuesta`) VALUES (1, 'Autenticación Exitosa');
INSERT INTO `dbChurchill`.`tipoRespuesta` (`idTipoRespuesta`, `tipoRespuesta`) VALUES (2, 'Usuario o Clave inválida');
INSERT INTO `dbChurchill`.`tipoRespuesta` (`idTipoRespuesta`, `tipoRespuesta`) VALUES (3, 'Usuario Bloqueado');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`tipoCliente`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`tipoCliente` (`idTipoCliente`, `tipoCliente`) VALUES (1, 'Individual');
INSERT INTO `dbChurchill`.`tipoCliente` (`idTipoCliente`, `tipoCliente`) VALUES (2, 'Juridico');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`cliente`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`cliente` (`idCliente`, `nit`, `nombre`, `cui`, `correo`, `telefono`, `direccion`, `idTipoCliente`, `fechaRegistro`, `usuario`) VALUES (1, 'CF', 'Consumidor Final', NULL, NULL, NULL, 'Ciudad', 1, '2017-08-01 00:00:00', 'restaurante');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`estadoMenu`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`estadoMenu` (`idEstadoMenu`, `estadoMenu`) VALUES (1, 'Activo');
INSERT INTO `dbChurchill`.`estadoMenu` (`idEstadoMenu`, `estadoMenu`) VALUES (2, 'Inactivo');
INSERT INTO `dbChurchill`.`estadoMenu` (`idEstadoMenu`, `estadoMenu`) VALUES (3, 'Eliminado');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`tipoMenu`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`tipoMenu` (`idTipoMenu`, `tipoMenu`) VALUES (1, 'Comida');
INSERT INTO `dbChurchill`.`tipoMenu` (`idTipoMenu`, `tipoMenu`) VALUES (2, 'Bebida');
INSERT INTO `dbChurchill`.`tipoMenu` (`idTipoMenu`, `tipoMenu`) VALUES (3, 'Licor');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`tipoProducto`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`tipoProducto` (`idTipoProducto`, `tipoProducto`) VALUES (1, 'Vegetales');
INSERT INTO `dbChurchill`.`tipoProducto` (`idTipoProducto`, `tipoProducto`) VALUES (2, 'Bebidas');
INSERT INTO `dbChurchill`.`tipoProducto` (`idTipoProducto`, `tipoProducto`) VALUES (3, 'Embutidos');
INSERT INTO `dbChurchill`.`tipoProducto` (`idTipoProducto`, `tipoProducto`) VALUES (4, 'Extra');
INSERT INTO `dbChurchill`.`tipoProducto` (`idTipoProducto`, `tipoProducto`) VALUES (5, 'Materia Principal');
INSERT INTO `dbChurchill`.`tipoProducto` (`idTipoProducto`, `tipoProducto`) VALUES (6, 'Condimento');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`medida`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`medida` (`idMedida`, `medida`) VALUES (1, 'Unidad');
INSERT INTO `dbChurchill`.`medida` (`idMedida`, `medida`) VALUES (2, 'Docena');
INSERT INTO `dbChurchill`.`medida` (`idMedida`, `medida`) VALUES (3, 'Onza');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`ubicacion`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`ubicacion` (`idUbicacion`, `ubicacion`) VALUES (1, 'Cocina');
INSERT INTO `dbChurchill`.`ubicacion` (`idUbicacion`, `ubicacion`) VALUES (2, 'Mostrador');
INSERT INTO `dbChurchill`.`ubicacion` (`idUbicacion`, `ubicacion`) VALUES (3, 'Bodega');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`tipoServicio`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`tipoServicio` (`idTipoServicio`, `tipoServicio`, `orden`) VALUES (1, 'Para llevar', 2);
INSERT INTO `dbChurchill`.`tipoServicio` (`idTipoServicio`, `tipoServicio`, `orden`) VALUES (2, 'Restaurante', 1);
INSERT INTO `dbChurchill`.`tipoServicio` (`idTipoServicio`, `tipoServicio`, `orden`) VALUES (3, 'A domicilio', 3);

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`estadoOrden`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`estadoOrden` (`idEstadoOrden`, `estadoOrden`) VALUES (1, 'Pendiente');
INSERT INTO `dbChurchill`.`estadoOrden` (`idEstadoOrden`, `estadoOrden`) VALUES (2, 'Cocinando');
INSERT INTO `dbChurchill`.`estadoOrden` (`idEstadoOrden`, `estadoOrden`) VALUES (3, 'Pendiente Entrega');
INSERT INTO `dbChurchill`.`estadoOrden` (`idEstadoOrden`, `estadoOrden`) VALUES (4, 'Servido');
INSERT INTO `dbChurchill`.`estadoOrden` (`idEstadoOrden`, `estadoOrden`) VALUES (5, 'Finalizado');
INSERT INTO `dbChurchill`.`estadoOrden` (`idEstadoOrden`, `estadoOrden`) VALUES (7, 'Programado (Evento)');
INSERT INTO `dbChurchill`.`estadoOrden` (`idEstadoOrden`, `estadoOrden`) VALUES (10, 'CANCELADO');
INSERT INTO `dbChurchill`.`estadoOrden` (`idEstadoOrden`, `estadoOrden`) VALUES (6, 'Facturado');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`estadoDetalleOrden`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`, `estadoDetalleOrden`) VALUES (1, 'Pendiente');
INSERT INTO `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`, `estadoDetalleOrden`) VALUES (2, 'Cocinando');
INSERT INTO `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`, `estadoDetalleOrden`) VALUES (3, 'Listo');
INSERT INTO `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`, `estadoDetalleOrden`) VALUES (4, 'Servido');
INSERT INTO `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`, `estadoDetalleOrden`) VALUES (5, 'En Factura');
INSERT INTO `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`, `estadoDetalleOrden`) VALUES (6, 'Facturado');
INSERT INTO `dbChurchill`.`estadoDetalleOrden` (`idEstadoDetalleOrden`, `estadoDetalleOrden`) VALUES (10, 'CANCELADO');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`estadoFactura`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`estadoFactura` (`idEstadoFactura`, `estadoFactura`) VALUES (1, 'Pagado');
INSERT INTO `dbChurchill`.`estadoFactura` (`idEstadoFactura`, `estadoFactura`) VALUES (2, 'Pendiente');
INSERT INTO `dbChurchill`.`estadoFactura` (`idEstadoFactura`, `estadoFactura`) VALUES (3, 'Pagado parcialmente');
INSERT INTO `dbChurchill`.`estadoFactura` (`idEstadoFactura`, `estadoFactura`) VALUES (10, 'Cancelado');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`estadoCaja`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`estadoCaja` (`idEstadoCaja`, `estadoCaja`) VALUES (1, 'Abierta');
INSERT INTO `dbChurchill`.`estadoCaja` (`idEstadoCaja`, `estadoCaja`) VALUES (2, 'Cerrada');
INSERT INTO `dbChurchill`.`estadoCaja` (`idEstadoCaja`, `estadoCaja`) VALUES (3, 'Cierre con Autorización');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`estadoEvento`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`estadoEvento` (`idEstadoEvento`, `estadoEvento`) VALUES (1, 'Programado');
INSERT INTO `dbChurchill`.`estadoEvento` (`idEstadoEvento`, `estadoEvento`) VALUES (5, 'Finalizado');
INSERT INTO `dbChurchill`.`estadoEvento` (`idEstadoEvento`, `estadoEvento`) VALUES (10, 'Cancelado');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`salon`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`salon` (`idSalon`, `salon`) VALUES (1, 'Salón Principal');
INSERT INTO `dbChurchill`.`salon` (`idSalon`, `salon`) VALUES (2, 'Salón # 2');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`estadoCuadre`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`estadoCuadre` (`idEstadoCuadre`, `estadoCuadre`) VALUES (1, 'Aperturado');
INSERT INTO `dbChurchill`.`estadoCuadre` (`idEstadoCuadre`, `estadoCuadre`) VALUES (2, 'Cerrado');
INSERT INTO `dbChurchill`.`estadoCuadre` (`idEstadoCuadre`, `estadoCuadre`) VALUES (3, 'Cuadre');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`formaPago`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`formaPago` (`idFormaPago`, `formaPago`, `porcentajeRecargo`, `montoRecargo`) VALUES (1, 'Efectivo', NULL, NULL);
INSERT INTO `dbChurchill`.`formaPago` (`idFormaPago`, `formaPago`, `porcentajeRecargo`, `montoRecargo`) VALUES (2, 'Tarjeta de Crédito', 0, NULL);

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`documento`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`documento` (`idDocumento`, `documento`) VALUES (1, 'Factura');
INSERT INTO `dbChurchill`.`documento` (`idDocumento`, `documento`) VALUES (2, 'Factura Evento');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`tipoItem`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`tipoItem` (`idTipoItem`, `tipoItem`) VALUES (1, 'Campo');
INSERT INTO `dbChurchill`.`tipoItem` (`idTipoItem`, `tipoItem`) VALUES (2, 'Lista');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`documentoDetalle`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`documentoDetalle` (`idDocumentoDetalle`, `idDocumento`, `idTipoItem`, `label`, `_index`, `x`, `y`, `mostrarTitulo`, `relativo`, `fontSize`) VALUES (1, 1, 1, 'NIT', 'nit', 15, 20, 1, 0, 13);
INSERT INTO `dbChurchill`.`documentoDetalle` (`idDocumentoDetalle`, `idDocumento`, `idTipoItem`, `label`, `_index`, `x`, `y`, `mostrarTitulo`, `relativo`, `fontSize`) VALUES (2, 1, 1, 'Nombre', 'nombre', 15, 35, 1, 0, 12);
INSERT INTO `dbChurchill`.`documentoDetalle` (`idDocumentoDetalle`, `idDocumento`, `idTipoItem`, `label`, `_index`, `x`, `y`, `mostrarTitulo`, `relativo`, `fontSize`) VALUES (3, 1, 1, 'Dirección', 'direccion', 15, 50, 1, 0, 12);
INSERT INTO `dbChurchill`.`documentoDetalle` (`idDocumentoDetalle`, `idDocumento`, `idTipoItem`, `label`, `_index`, `x`, `y`, `mostrarTitulo`, `relativo`, `fontSize`) VALUES (4, 1, 2, 'Detalle Factura', 'lstDetalle', 15, 75, 0, 0, 12);
INSERT INTO `dbChurchill`.`documentoDetalle` (`idDocumentoDetalle`, `idDocumento`, `idTipoItem`, `label`, `_index`, `x`, `y`, `mostrarTitulo`, `relativo`, `fontSize`) VALUES (5, 2, 1, 'NIT', 'nit', 15, 20, 1, 0, 13);
INSERT INTO `dbChurchill`.`documentoDetalle` (`idDocumentoDetalle`, `idDocumento`, `idTipoItem`, `label`, `_index`, `x`, `y`, `mostrarTitulo`, `relativo`, `fontSize`) VALUES (6, 2, 1, 'Nombre', 'nombre', 15, 35, 1, 0, 12);
INSERT INTO `dbChurchill`.`documentoDetalle` (`idDocumentoDetalle`, `idDocumento`, `idTipoItem`, `label`, `_index`, `x`, `y`, `mostrarTitulo`, `relativo`, `fontSize`) VALUES (7, 2, 1, 'Dirección', 'direccion', 15, 50, 1, 0, 12);
INSERT INTO `dbChurchill`.`documentoDetalle` (`idDocumentoDetalle`, `idDocumento`, `idTipoItem`, `label`, `_index`, `x`, `y`, `mostrarTitulo`, `relativo`, `fontSize`) VALUES (8, 2, 2, 'Detalle Factura', 'lstDetalle', 15, 75, 0, 0, 12);

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`columnaLista`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`columnaLista` (`idColumnaLista`, `idDocumentoDetalle`, `campo`, `_index`, `width`, `orden`) VALUES (2, 4, 'Descripción', 'descripcion', 200, 2);
INSERT INTO `dbChurchill`.`columnaLista` (`idColumnaLista`, `idDocumentoDetalle`, `campo`, `_index`, `width`, `orden`) VALUES (3, 4, 'Cantidad', 'cantidad', 55, 1);
INSERT INTO `dbChurchill`.`columnaLista` (`idColumnaLista`, `idDocumentoDetalle`, `campo`, `_index`, `width`, `orden`) VALUES (4, 4, 'P/U', 'precioReal', 55, 3);
INSERT INTO `dbChurchill`.`columnaLista` (`idColumnaLista`, `idDocumentoDetalle`, `campo`, `_index`, `width`, `orden`) VALUES (5, 4, 'Subtotal', 'subTotal', 55, 4);
INSERT INTO `dbChurchill`.`columnaLista` (`idColumnaLista`, `idDocumentoDetalle`, `campo`, `_index`, `width`, `orden`) VALUES (7, 8, 'Cantidad', 'cantidad', 55, 1);
INSERT INTO `dbChurchill`.`columnaLista` (`idColumnaLista`, `idDocumentoDetalle`, `campo`, `_index`, `width`, `orden`) VALUES (8, 8, 'Descripción', 'descripcion', 200, 2);
INSERT INTO `dbChurchill`.`columnaLista` (`idColumnaLista`, `idDocumentoDetalle`, `campo`, `_index`, `width`, `orden`) VALUES (9, 8, 'Subtotal', 'subTotal', 60, 3);

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`denominacion`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (0.01, 0, 'Moneda(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (0.05, 1, 'Moneda(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (0.10, 1, 'Moneda(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (0.25, 1, 'Moneda(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (0.50, 1, 'Moneda(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (1.00, 1, 'Moneda(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (5.00, 1, 'Billete(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (10.00, 1, 'Billete(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (20.00, 1, 'Billete(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (50.00, 1, 'Billete(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (100.00, 1, 'Billete(s)');
INSERT INTO `dbChurchill`.`denominacion` (`denominacion`, `estado`, `descripcion`) VALUES (200.00, 1, 'Billete(s)');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`estadoMovimiento`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`estadoMovimiento` (`idEstadoMovimiento`, `estadoMovimiento`) VALUES (1, 'Pendiente');
INSERT INTO `dbChurchill`.`estadoMovimiento` (`idEstadoMovimiento`, `estadoMovimiento`) VALUES (5, 'Realizado');
INSERT INTO `dbChurchill`.`estadoMovimiento` (`idEstadoMovimiento`, `estadoMovimiento`) VALUES (10, 'Reversado');

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`tipoMovimiento`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`tipoMovimiento` (`idTipoMovimiento`, `tipoMovimiento`, `ingreso`) VALUES (1, 'Anticipo Evento', 1);
INSERT INTO `dbChurchill`.`tipoMovimiento` (`idTipoMovimiento`, `tipoMovimiento`, `ingreso`) VALUES (2, 'Pago Extra Evento', 1);
INSERT INTO `dbChurchill`.`tipoMovimiento` (`idTipoMovimiento`, `tipoMovimiento`, `ingreso`) VALUES (3, 'Ingreso', 1);
INSERT INTO `dbChurchill`.`tipoMovimiento` (`idTipoMovimiento`, `tipoMovimiento`, `ingreso`) VALUES (4, 'Egreso', 0);

COMMIT;


-- -----------------------------------------------------
-- Data for table `dbChurchill`.`parametro`
-- -----------------------------------------------------
START TRANSACTION;
USE `dbChurchill`;
INSERT INTO `dbChurchill`.`parametro` (`idParametro`, `parametro`, `valor`) VALUES ('gruposCocina', 'Grupos de Cocina', '1');

COMMIT;

